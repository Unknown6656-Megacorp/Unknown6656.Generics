
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
////////////////////////////////////////////////////// AUTOGENERATED //////////////////////////////////////////////////////
// WARNING: All code changes to this file will be lost upon regeneration.                                                //
// Autogenerated on <#=$"{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffffff}"#>                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System;

namespace Unknown6656.Generics;

<#const string default_dict = "DelayedCachedDictionary";#>

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
public static partial class FuncCache
{
    /// <summary>
    /// Returns the <see cref="Type"/> information for the default dictionary datastructure, which is used for the generalized function caches.
    /// <para/>
    /// The type defaults to <see cref="<#=default_dict#>{K,V}"/>.
    /// <para/>
    /// If you want to change this type, you either have to provide a custom Dictionary to the <typeparamref name="TDict"/> generic parameter of the type <see cref="_FuncCache{TDict, TKey0, Value}"/>.
    /// Otherwise, you'll have to recompile "Unknown6656.<see cref="Unknown6656.Generics"/>" with your custom implementation.
    /// Please refer to <a href="https://github.com/Unknown6656-Megacorp/Unknown6656.Generics/blob/master/Cached.tt">Cached.tt</a>.
    /// </summary>
    public static Type DefaultDictionaryCacheType { get; } = typeof(<#=default_dict#><,>);
}

<#
    int maxsize = 10;

    try
    {
        string path = Host.ResolvePath("maxdim.txt");

        maxsize = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

    for (int dim = 1; dim < maxsize; ++dim)
    {
        string argnames = string.Join(", ", r(0, dim).Select(i => "key" + i));
        string typenames = string.Join(", ", r(0, dim).Select(i => "TKey" + i));
        string tupletypes = string.Join(", ", r(0, dim).Select(i => $"TKey{i} key{i}"));
        string dicttypenames = dim == 1 ? "TKey0" : $"({tupletypes})";
#>
/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
<#
        for (int i = 0; i < dim; ++i)
            WriteLine($"/// <typeparam name=\"TKey{i}\">The generic parameter type of argument no. {i}.</typeparam>");
#>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, <#=typenames#>, TValue>
    where TDict : IDictionary<<#=dicttypenames#>, TValue>, new()
<#
        if (dim == 1)
            WriteLine("    where TKey0 : notnull");
#>
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<<#=typenames#>, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[<#=tupletypes#>] => Invoke(<#=argnames#>);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<<#=typenames#>, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<<#=typenames#>, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
<#
        for (int i = 0; i < dim; ++i)
            WriteLine($"    /// <param name=\"key{i}\">The function argument no. {i}.</param>");
#>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(<#=tupletypes#>)
    {
        var key = (<#=argnames#>);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(<#=argnames#>);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {<#=string.Join("} x {", r(0, dim).Select(i => $"typeof(TKey{i})"))#>} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, <#=typenames#>, TValue}._FuncCache(Func{<#=typenames#>, TValue})"/>
    public static implicit operator _FuncCache<TDict, <#=typenames#>, TValue>(Func<<#=typenames#>, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, <#=typenames#>, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<<#=typenames#>, TValue>(_FuncCache<TDict, <#=typenames#>, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<<#=typenames#>, TValue>
    : _FuncCache<<#=default_dict#><<#=dicttypenames#>, TValue>, <#=typenames#>, TValue>
<#
        if (dim == 1)
            WriteLine("    where TKey0 : notnull");
#>
{
    /// <inheritdoc cref="_FuncCache{TDict, <#=typenames#>, TValue}._FuncCache(Func{<#=typenames#>, TValue})"/>
    public FuncCache(Func<<#=typenames#>, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, <#=typenames#>, TValue}._FuncCache(delegate*{<#=typenames#>, TValue})"/>
    public unsafe FuncCache(delegate*<<#=typenames#>, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{<#=typenames#>, TValue}.FuncCache(Func{<#=typenames#>, TValue})"/>
    public static implicit operator FuncCache<<#=typenames#>, TValue>(Func<<#=typenames#>, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{<#=typenames#>, TValue}.FuncCache(Func{<#=typenames#>, TValue})"/>
    public static FuncCache<<#=typenames#>, TValue> Cached<<#=typenames#>, TValue>(this Func<<#=typenames#>, TValue> function)
        <#=dim == 1 ? "where TKey0 : notnull " : ""#>=> new(function);
}

<#
    }
#>

////////////////////////////////////////////////////// AUTOGENERATED //////////////////////////////////////////////////////
// WARNING: All code changes to this file will be lost upon regeneration.                                                //
// Autogenerated on 2022-03-07 11:36:24:146523                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;
using System;

namespace Unknown6656.Generics;


public static unsafe partial class LINQ
{

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1) Join<T0, T1>(this T0 t0, T1 t1) =>
        (t0, t1);

    /// <summary>
    /// Creates a new array with exactly 2 elements from the given 2-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 2-tuple.</param>
    /// <returns>The array (Length = 2) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1) tuple) =>
        new[] { tuple.t0, tuple.t1 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1) Apply<T, U>(this (T e0, T e1) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this (T0 left, (T1, T2) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this T0 left, (T1, T2) right) =>
        (left, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this ((T0, T1) left, T2 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this (T0, T1) left, T2 right) =>
        (left.Item1, left.Item2, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this T0 t0, T1 t1, T2 t2) =>
        (t0, t1, t2);

    /// <summary>
    /// Creates a new array with exactly 3 elements from the given 3-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 3-tuple.</param>
    /// <returns>The array (Length = 3) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2) Apply<T, U>(this (T e0, T e1, T e2) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this (T0 left, (T1, T2, T3) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this T0 left, (T1, T2, T3) right) =>
        (left, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this ((T0, T1) left, (T2, T3) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this (T0, T1) left, (T2, T3) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this ((T0, T1, T2) left, T3 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this (T0, T1, T2) left, T3 right) =>
        (left.Item1, left.Item2, left.Item3, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this T0 t0, T1 t1, T2 t2, T3 t3) =>
        (t0, t1, t2, t3);

    /// <summary>
    /// Creates a new array with exactly 4 elements from the given 4-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 4-tuple.</param>
    /// <returns>The array (Length = 4) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3) Apply<T, U>(this (T e0, T e1, T e2, T e3) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this (T0 left, (T1, T2, T3, T4) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this T0 left, (T1, T2, T3, T4) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this ((T0, T1) left, (T2, T3, T4) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this (T0, T1) left, (T2, T3, T4) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this ((T0, T1, T2) left, (T3, T4) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this (T0, T1, T2) left, (T3, T4) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this ((T0, T1, T2, T3) left, T4 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this (T0, T1, T2, T3) left, T4 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4) =>
        (t0, t1, t2, t3, t4);

    /// <summary>
    /// Creates a new array with exactly 5 elements from the given 5-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 5-tuple.</param>
    /// <returns>The array (Length = 5) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0 left, (T1, T2, T3, T4, T5) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this T0 left, (T1, T2, T3, T4, T5) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this ((T0, T1) left, (T2, T3, T4, T5) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0, T1) left, (T2, T3, T4, T5) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this ((T0, T1, T2) left, (T3, T4, T5) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0, T1, T2) left, (T3, T4, T5) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this ((T0, T1, T2, T3) left, (T4, T5) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0, T1, T2, T3) left, (T4, T5) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this ((T0, T1, T2, T3, T4) left, T5 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0, T1, T2, T3, T4) left, T5 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) =>
        (t0, t1, t2, t3, t4, t5);

    /// <summary>
    /// Creates a new array with exactly 6 elements from the given 6-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 6-tuple.</param>
    /// <returns>The array (Length = 6) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0 left, (T1, T2, T3, T4, T5, T6) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this T0 left, (T1, T2, T3, T4, T5, T6) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1) left, (T2, T3, T4, T5, T6) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1) left, (T2, T3, T4, T5, T6) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1, T2) left, (T3, T4, T5, T6) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1, T2) left, (T3, T4, T5, T6) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1, T2, T3) left, (T4, T5, T6) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1, T2, T3) left, (T4, T5, T6) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1, T2, T3, T4) left, (T5, T6) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1, T2, T3, T4) left, (T5, T6) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1, T2, T3, T4, T5) left, T6 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1, T2, T3, T4, T5) left, T6 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) =>
        (t0, t1, t2, t3, t4, t5, t6);

    /// <summary>
    /// Creates a new array with exactly 7 elements from the given 7-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 7-tuple.</param>
    /// <returns>The array (Length = 7) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this T0 left, (T1, T2, T3, T4, T5, T6, T7) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2, T3, T4, T5, T6) left, T7 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2, T3, T4, T5, T6) left, T7 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) =>
        (t0, t1, t2, t3, t4, t5, t6, t7);

    /// <summary>
    /// Creates a new array with exactly 8 elements from the given 8-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 8-tuple.</param>
    /// <returns>The array (Length = 8) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, T8 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, T8 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8);

    /// <summary>
    /// Creates a new array with exactly 9 elements from the given 9-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 9-tuple.</param>
    /// <returns>The array (Length = 9) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8) left, T9 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8) left, T9 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <param name="t9">The tuple element at position 10.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/> for the argument <paramref name="t9"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);

    /// <summary>
    /// Creates a new array with exactly 10 elements from the given 10-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 10-tuple.</param>
    /// <returns>The array (Length = 10) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8, tuple.t9 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8, U e9) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8), func(x.e9));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, T10 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, T10 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <param name="t9">The tuple element at position 10.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/> for the argument <paramref name="t9"/>.</typeparam>
    /// <param name="t10">The tuple element at position 11.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/> for the argument <paramref name="t10"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10);

    /// <summary>
    /// Creates a new array with exactly 11 elements from the given 11-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 11-tuple.</param>
    /// <returns>The array (Length = 11) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T t10) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8, tuple.t9, tuple.t10 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8, U e9, U e10) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9, T e10) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8), func(x.e9), func(x.e10));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, T11 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, T11 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <param name="t9">The tuple element at position 10.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/> for the argument <paramref name="t9"/>.</typeparam>
    /// <param name="t10">The tuple element at position 11.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/> for the argument <paramref name="t10"/>.</typeparam>
    /// <param name="t11">The tuple element at position 12.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/> for the argument <paramref name="t11"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11);

    /// <summary>
    /// Creates a new array with exactly 12 elements from the given 12-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 12-tuple.</param>
    /// <returns>The array (Length = 12) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T t10, T t11) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8, tuple.t9, tuple.t10, tuple.t11 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8, U e9, U e10, U e11) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9, T e10, T e11) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8), func(x.e9), func(x.e10), func(x.e11));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, (T11, T12) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, (T11, T12) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) left, T12 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) left, T12 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <param name="t9">The tuple element at position 10.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/> for the argument <paramref name="t9"/>.</typeparam>
    /// <param name="t10">The tuple element at position 11.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/> for the argument <paramref name="t10"/>.</typeparam>
    /// <param name="t11">The tuple element at position 12.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/> for the argument <paramref name="t11"/>.</typeparam>
    /// <param name="t12">The tuple element at position 13.</param>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/> for the argument <paramref name="t12"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12);

    /// <summary>
    /// Creates a new array with exactly 13 elements from the given 13-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 13-tuple.</param>
    /// <returns>The array (Length = 13) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T t10, T t11, T t12) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8, tuple.t9, tuple.t10, tuple.t11, tuple.t12 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8, U e9, U e10, U e11, U e12) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9, T e10, T e11, T e12) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8), func(x.e9), func(x.e10), func(x.e11), func(x.e12));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12, tuple.right.Item13);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12, right.Item13);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, (T11, T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, (T11, T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) left, (T12, T13) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) left, (T12, T13) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) left, T13 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.left.Item13, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) left, T13 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, left.Item13, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <param name="t9">The tuple element at position 10.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/> for the argument <paramref name="t9"/>.</typeparam>
    /// <param name="t10">The tuple element at position 11.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/> for the argument <paramref name="t10"/>.</typeparam>
    /// <param name="t11">The tuple element at position 12.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/> for the argument <paramref name="t11"/>.</typeparam>
    /// <param name="t12">The tuple element at position 13.</param>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/> for the argument <paramref name="t12"/>.</typeparam>
    /// <param name="t13">The tuple element at position 14.</param>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/> for the argument <paramref name="t13"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13);

    /// <summary>
    /// Creates a new array with exactly 14 elements from the given 14-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 14-tuple.</param>
    /// <returns>The array (Length = 14) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T t10, T t11, T t12, T t13) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8, tuple.t9, tuple.t10, tuple.t11, tuple.t12, tuple.t13 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8, U e9, U e10, U e11, U e12, U e13) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9, T e10, T e11, T e12, T e13) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8), func(x.e9), func(x.e10), func(x.e11), func(x.e12), func(x.e13));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12, tuple.right.Item13, tuple.right.Item14);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12, right.Item13, right.Item14);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12, tuple.right.Item13);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12, right.Item13);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, (T11, T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, (T11, T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) left, (T12, T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) left, (T12, T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) left, (T13, T14) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.left.Item13, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) left, (T13, T14) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, left.Item13, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) left, T14 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.left.Item13, tuple.left.Item14, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) left, T14 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, left.Item13, left.Item14, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <param name="t9">The tuple element at position 10.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/> for the argument <paramref name="t9"/>.</typeparam>
    /// <param name="t10">The tuple element at position 11.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/> for the argument <paramref name="t10"/>.</typeparam>
    /// <param name="t11">The tuple element at position 12.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/> for the argument <paramref name="t11"/>.</typeparam>
    /// <param name="t12">The tuple element at position 13.</param>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/> for the argument <paramref name="t12"/>.</typeparam>
    /// <param name="t13">The tuple element at position 14.</param>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/> for the argument <paramref name="t13"/>.</typeparam>
    /// <param name="t14">The tuple element at position 15.</param>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/> for the argument <paramref name="t14"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14);

    /// <summary>
    /// Creates a new array with exactly 15 elements from the given 15-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 15-tuple.</param>
    /// <returns>The array (Length = 15) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T t10, T t11, T t12, T t13, T t14) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8, tuple.t9, tuple.t10, tuple.t11, tuple.t12, tuple.t13, tuple.t14 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8, U e9, U e10, U e11, U e12, U e13, U e14) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9, T e10, T e11, T e12, T e13, T e14) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8), func(x.e9), func(x.e10), func(x.e11), func(x.e12), func(x.e13), func(x.e14));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12, tuple.right.Item13, tuple.right.Item14, tuple.right.Item15);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12, right.Item13, right.Item14, right.Item15);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12, tuple.right.Item13, tuple.right.Item14);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12, right.Item13, right.Item14);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12, tuple.right.Item13);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12, right.Item13);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11, tuple.right.Item12);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11, right.Item12);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10, tuple.right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10, right.Item11);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9, tuple.right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9, right.Item10);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9, T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9, T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8) left, (T9, T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) left, (T10, T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, (T11, T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) left, (T11, T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) left, (T12, T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) left, (T12, T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) left, (T13, T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.left.Item13, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) left, (T13, T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, left.Item13, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) left, (T14, T15) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.left.Item13, tuple.left.Item14, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) left, (T14, T15) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, left.Item13, left.Item14, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) left, T15 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.left.Item10, tuple.left.Item11, tuple.left.Item12, tuple.left.Item13, tuple.left.Item14, tuple.left.Item15, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) left, T15 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, left.Item10, left.Item11, left.Item12, left.Item13, left.Item14, left.Item15, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <param name="t9">The tuple element at position 10.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/> for the argument <paramref name="t9"/>.</typeparam>
    /// <param name="t10">The tuple element at position 11.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/> for the argument <paramref name="t10"/>.</typeparam>
    /// <param name="t11">The tuple element at position 12.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/> for the argument <paramref name="t11"/>.</typeparam>
    /// <param name="t12">The tuple element at position 13.</param>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/> for the argument <paramref name="t12"/>.</typeparam>
    /// <param name="t13">The tuple element at position 14.</param>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/> for the argument <paramref name="t13"/>.</typeparam>
    /// <param name="t14">The tuple element at position 15.</param>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/> for the argument <paramref name="t14"/>.</typeparam>
    /// <param name="t15">The tuple element at position 16.</param>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/> for the argument <paramref name="t15"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13, T14 t14, T15 t15) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15);

    /// <summary>
    /// Creates a new array with exactly 16 elements from the given 16-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 16-tuple.</param>
    /// <returns>The array (Length = 16) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9, T t10, T t11, T t12, T t13, T t14, T t15) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8, tuple.t9, tuple.t10, tuple.t11, tuple.t12, tuple.t13, tuple.t14, tuple.t15 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8, U e9, U e10, U e11, U e12, U e13, U e14, U e15) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9, T e10, T e11, T e12, T e13, T e14, T e15) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8), func(x.e9), func(x.e10), func(x.e11), func(x.e12), func(x.e13), func(x.e14), func(x.e15));

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// </summary>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<void> ToActionPointer(void* pointer) => (delegate*<void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <see langword="void"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction(void* pointer) => ToActionPointer(pointer)();

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    ///  -> <typeparamref name="T0"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0> ToFunctionPointer<T0>(void* pointer) =>
        (delegate*<T0>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, void> ToActionPointer<T0>(void* pointer) =>
        (delegate*<T0, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    ///  -> <typeparamref name="T0"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T0 InvokeFunction<T0>(void* pointer) =>
        ToFunctionPointer<T0>(pointer)();

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0>(void* pointer, T0 arg0) =>
        ToActionPointer<T0>(pointer)(arg0);

    /// <summary>
    /// Maps the given 2-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 2-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,] Select<T, U>(this T[,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        U[,] result = new U[dim0, dim1];

        Parallel.For(0, dim0 * dim1, i => {
            int index0 = i / dim1;
            int index1 = i % dim1;

            result[index0, index1] = map(array[index0, index1]);
        });

        return result;
    }


    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/> -> <typeparamref name="T1"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1> ToFunctionPointer<T0, T1>(void* pointer) =>
        (delegate*<T0, T1>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, void> ToActionPointer<T0, T1>(void* pointer) =>
        (delegate*<T0, T1, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/> -> <typeparamref name="T1"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T1 InvokeFunction<T0, T1>(void* pointer, T0 arg0) =>
        ToFunctionPointer<T0, T1>(pointer)(arg0);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1>(void* pointer, T0 arg0, T1 arg1) =>
        ToActionPointer<T0, T1>(pointer)(arg0, arg1);

    /// <summary>
    /// Maps the given 3-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 3-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,] Select<T, U>(this T[,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        U[,,] result = new U[dim0, dim1, dim2];

        Parallel.For(0, dim0 * dim1 * dim2, i => {
            int index0 = i / dim2 / dim1;
            int index1 = i / dim2 % dim1;
            int index2 = i % dim2;

            result[index0, index1, index2] = map(array[index0, index1, index2]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(collection));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim2;
            int index2 = i % dim2;

            reshaped[index1, index2] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 2-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 2-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        T[] flattened = new T[dim1 * dim2];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim2;
            int index2 = i % dim2;

            flattened[i] = array[index1, index2];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 2-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 2-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int insize = indim1 * indim2;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim2;
            int inindex2 = i % indim2;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/> -> <typeparamref name="T2"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2> ToFunctionPointer<T0, T1, T2>(void* pointer) =>
        (delegate*<T0, T1, T2>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, void> ToActionPointer<T0, T1, T2>(void* pointer) =>
        (delegate*<T0, T1, T2, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/> -> <typeparamref name="T2"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T2 InvokeFunction<T0, T1, T2>(void* pointer, T0 arg0, T1 arg1) =>
        ToFunctionPointer<T0, T1, T2>(pointer)(arg0, arg1);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2>(void* pointer, T0 arg0, T1 arg1, T2 arg2) =>
        ToActionPointer<T0, T1, T2>(pointer)(arg0, arg1, arg2);

    /// <summary>
    /// Maps the given 4-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 4-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,] Select<T, U>(this T[,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        U[,,,] result = new U[dim0, dim1, dim2, dim3];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3, i => {
            int index0 = i / dim3 / dim2 / dim1;
            int index1 = i / dim3 / dim2 % dim1;
            int index2 = i / dim3 % dim2;
            int index3 = i % dim3;

            result[index0, index1, index2, index3] = map(array[index0, index1, index2, index3]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(collection));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim3 / dim2;
            int index2 = i / dim3 % dim2;
            int index3 = i % dim3;

            reshaped[index1, index2, index3] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 3-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 3-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        T[] flattened = new T[dim1 * dim2 * dim3];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim3 / dim2;
            int index2 = i / dim3 % dim2;
            int index3 = i % dim3;

            flattened[i] = array[index1, index2, index3];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 3-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 3-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int insize = indim1 * indim2 * indim3;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim3 / indim2;
            int inindex2 = i / indim3 % indim2;
            int inindex3 = i % indim3;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 3-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 3-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int insize = indim1 * indim2 * indim3;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim3 / indim2;
            int inindex2 = i / indim3 % indim2;
            int inindex3 = i % indim3;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/> -> <typeparamref name="T3"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3> ToFunctionPointer<T0, T1, T2, T3>(void* pointer) =>
        (delegate*<T0, T1, T2, T3>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, void> ToActionPointer<T0, T1, T2, T3>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/> -> <typeparamref name="T3"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T3 InvokeFunction<T0, T1, T2, T3>(void* pointer, T0 arg0, T1 arg1, T2 arg2) =>
        ToFunctionPointer<T0, T1, T2, T3>(pointer)(arg0, arg1, arg2);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3) =>
        ToActionPointer<T0, T1, T2, T3>(pointer)(arg0, arg1, arg2, arg3);

    /// <summary>
    /// Maps the given 5-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 5-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,] Select<T, U>(this T[,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        U[,,,,] result = new U[dim0, dim1, dim2, dim3, dim4];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4, i => {
            int index0 = i / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim4 / dim3 % dim2;
            int index3 = i / dim4 % dim3;
            int index4 = i % dim4;

            result[index0, index1, index2, index3, index4] = map(array[index0, index1, index2, index3, index4]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(collection));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim4 / dim3 / dim2;
            int index2 = i / dim4 / dim3 % dim2;
            int index3 = i / dim4 % dim3;
            int index4 = i % dim4;

            reshaped[index1, index2, index3, index4] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 4-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 4-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim4 / dim3 / dim2;
            int index2 = i / dim4 / dim3 % dim2;
            int index3 = i / dim4 % dim3;
            int index4 = i % dim4;

            flattened[i] = array[index1, index2, index3, index4];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 4-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 4-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int insize = indim1 * indim2 * indim3 * indim4;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim4 / indim3 / indim2;
            int inindex2 = i / indim4 / indim3 % indim2;
            int inindex3 = i / indim4 % indim3;
            int inindex4 = i % indim4;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 4-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 4-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int insize = indim1 * indim2 * indim3 * indim4;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim4 / indim3 / indim2;
            int inindex2 = i / indim4 / indim3 % indim2;
            int inindex3 = i / indim4 % indim3;
            int inindex4 = i % indim4;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 4-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 4-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int insize = indim1 * indim2 * indim3 * indim4;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim4 / indim3 / indim2;
            int inindex2 = i / indim4 / indim3 % indim2;
            int inindex3 = i / indim4 % indim3;
            int inindex4 = i % indim4;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/> -> <typeparamref name="T4"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4> ToFunctionPointer<T0, T1, T2, T3, T4>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, void> ToActionPointer<T0, T1, T2, T3, T4>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/> -> <typeparamref name="T4"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T4 InvokeFunction<T0, T1, T2, T3, T4>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3) =>
        ToFunctionPointer<T0, T1, T2, T3, T4>(pointer)(arg0, arg1, arg2, arg3);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) =>
        ToActionPointer<T0, T1, T2, T3, T4>(pointer)(arg0, arg1, arg2, arg3, arg4);

    /// <summary>
    /// Maps the given 6-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 6-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,] Select<T, U>(this T[,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        U[,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5, i => {
            int index0 = i / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim5 / dim4 % dim3;
            int index4 = i / dim5 % dim4;
            int index5 = i % dim5;

            result[index0, index1, index2, index3, index4, index5] = map(array[index0, index1, index2, index3, index4, index5]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(collection));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim5 / dim4 % dim3;
            int index4 = i / dim5 % dim4;
            int index5 = i % dim5;

            reshaped[index1, index2, index3, index4, index5] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 5-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim5 / dim4 % dim3;
            int index4 = i / dim5 % dim4;
            int index5 = i % dim5;

            flattened[i] = array[index1, index2, index3, index4, index5];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 5-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim5 / indim4 % indim3;
            int inindex4 = i / indim5 % indim4;
            int inindex5 = i % indim5;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 5-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim5 / indim4 % indim3;
            int inindex4 = i / indim5 % indim4;
            int inindex5 = i % indim5;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 5-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim5 / indim4 % indim3;
            int inindex4 = i / indim5 % indim4;
            int inindex5 = i % indim5;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 5-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim5 / indim4 % indim3;
            int inindex4 = i / indim5 % indim4;
            int inindex5 = i % indim5;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/> -> <typeparamref name="T5"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5> ToFunctionPointer<T0, T1, T2, T3, T4, T5>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, void> ToActionPointer<T0, T1, T2, T3, T4, T5>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/> -> <typeparamref name="T5"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T5 InvokeFunction<T0, T1, T2, T3, T4, T5>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5>(pointer)(arg0, arg1, arg2, arg3, arg4);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5);

    /// <summary>
    /// Maps the given 7-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 7-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,] Select<T, U>(this T[,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        U[,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6, i => {
            int index0 = i / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim6 / dim5 % dim4;
            int index5 = i / dim6 % dim5;
            int index6 = i % dim6;

            result[index0, index1, index2, index3, index4, index5, index6] = map(array[index0, index1, index2, index3, index4, index5, index6]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(collection));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim6 / dim5 % dim4;
            int index5 = i / dim6 % dim5;
            int index6 = i % dim6;

            reshaped[index1, index2, index3, index4, index5, index6] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 6-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim6 / dim5 % dim4;
            int index5 = i / dim6 % dim5;
            int index6 = i % dim6;

            flattened[i] = array[index1, index2, index3, index4, index5, index6];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/> -> <typeparamref name="T6"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/> -> <typeparamref name="T6"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T6 InvokeFunction<T0, T1, T2, T3, T4, T5, T6>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6);

    /// <summary>
    /// Maps the given 8-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 8-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,] Select<T, U>(this T[,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        U[,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7, i => {
            int index0 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim7 / dim6 % dim5;
            int index6 = i / dim7 % dim6;
            int index7 = i % dim7;

            result[index0, index1, index2, index3, index4, index5, index6, index7] = map(array[index0, index1, index2, index3, index4, index5, index6, index7]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(collection));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim7 / dim6 % dim5;
            int index6 = i / dim7 % dim6;
            int index7 = i % dim7;

            reshaped[index1, index2, index3, index4, index5, index6, index7] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 7-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim7 / dim6 % dim5;
            int index6 = i / dim7 % dim6;
            int index7 = i % dim7;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/> -> <typeparamref name="T7"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/> -> <typeparamref name="T7"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T7 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

    /// <summary>
    /// Maps the given 9-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 9-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,] Select<T, U>(this T[,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        U[,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8, i => {
            int index0 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim8 / dim7 % dim6;
            int index7 = i / dim8 % dim7;
            int index8 = i % dim8;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(collection));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim8 / dim7 % dim6;
            int index7 = i / dim8 % dim7;
            int index8 = i % dim8;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 8-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim8 / dim7 % dim6;
            int index7 = i / dim8 % dim7;
            int index8 = i % dim8;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/> -> <typeparamref name="T8"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/> -> <typeparamref name="T8"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T8 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

    /// <summary>
    /// Maps the given 10-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 10-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        U[,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9, i => {
            int index0 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim9 / dim8 % dim7;
            int index8 = i / dim9 % dim8;
            int index9 = i % dim9;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(collection));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim9 / dim8 % dim7;
            int index8 = i / dim9 % dim8;
            int index9 = i % dim9;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 9-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim9 / dim8 % dim7;
            int index8 = i / dim9 % dim8;
            int index9 = i % dim9;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/> -> <typeparamref name="T9"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/> -> <typeparamref name="T9"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T9 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg9">The argument no. 10.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

    /// <summary>
    /// Maps the given 11-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 11-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 11-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        U[,,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10, i => {
            int index0 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim10 / dim9 % dim8;
            int index9 = i / dim10 % dim9;
            int index10 = i % dim10;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(collection));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim10 / dim9 % dim8;
            int index9 = i / dim10 % dim9;
            int index10 = i % dim10;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 10-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim10 / dim9 % dim8;
            int index9 = i / dim10 % dim9;
            int index10 = i % dim10;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 10-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The reshaped 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(array));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim10 / dim9 % dim8;
            int outindex9 = i / dim10 % dim9;
            int outindex10 = i % dim10;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/> -> <typeparamref name="T10"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/> -> <typeparamref name="T10"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="arg9">The argument no. 10.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T10 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg9">The argument no. 10.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="arg10">The argument no. 11.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);

    /// <summary>
    /// Maps the given 12-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 12-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 12-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        U[,,,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11, i => {
            int index0 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim11 / dim10 % dim9;
            int index10 = i / dim11 % dim10;
            int index11 = i % dim11;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11}.", nameof(collection));

        T[,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim11 / dim10 % dim9;
            int index10 = i / dim11 % dim10;
            int index11 = i % dim11;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 11-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim11 / dim10 % dim9;
            int index10 = i / dim11 % dim10;
            int index11 = i % dim11;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 10-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(array));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim10 / dim9 % dim8;
            int outindex9 = i / dim10 % dim9;
            int outindex10 = i % dim10;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 11-dimensional array into a 11-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 11-dimensional input array.</param>
    /// <returns>The reshaped 11-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11}.", nameof(array));

        T[,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim11 / dim10 % dim9;
            int outindex10 = i / dim11 % dim10;
            int outindex11 = i % dim11;
            int inindex1 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim11 / indim10 % indim9;
            int inindex10 = i / indim11 % indim10;
            int inindex11 = i % indim11;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/> -> <typeparamref name="T11"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/> -> <typeparamref name="T11"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="arg9">The argument no. 10.</param>
    /// <param name="arg10">The argument no. 11.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T11 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg9">The argument no. 10.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="arg10">The argument no. 11.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="arg11">The argument no. 12.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);

    /// <summary>
    /// Maps the given 13-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 13-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 13-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        U[,,,,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12, i => {
            int index0 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim12 / dim11 % dim10;
            int index11 = i / dim12 % dim11;
            int index12 = i % dim12;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12}.", nameof(collection));

        T[,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim12 / dim11 % dim10;
            int index11 = i / dim12 % dim11;
            int index12 = i % dim12;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 12-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim12 / dim11 % dim10;
            int index11 = i / dim12 % dim11;
            int index12 = i % dim12;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 10-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(array));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim10 / dim9 % dim8;
            int outindex9 = i / dim10 % dim9;
            int outindex10 = i % dim10;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 11-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 11-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11}.", nameof(array));

        T[,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim11 / dim10 % dim9;
            int outindex10 = i / dim11 % dim10;
            int outindex11 = i % dim11;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 12-dimensional array into a 12-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 12-dimensional input array.</param>
    /// <returns>The reshaped 12-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12}.", nameof(array));

        T[,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim12 / dim11 % dim10;
            int outindex11 = i / dim12 % dim11;
            int outindex12 = i % dim12;
            int inindex1 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim12 / indim11 % indim10;
            int inindex11 = i / indim12 % indim11;
            int inindex12 = i % indim12;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/> -> <typeparamref name="T12"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/> -> <typeparamref name="T12"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="arg9">The argument no. 10.</param>
    /// <param name="arg10">The argument no. 11.</param>
    /// <param name="arg11">The argument no. 12.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T12 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg9">The argument no. 10.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="arg10">The argument no. 11.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="arg11">The argument no. 12.</param>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="arg12">The argument no. 13.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);

    /// <summary>
    /// Maps the given 14-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 14-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 14-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        int dim13 = array.GetLength(13);
        U[,,,,,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13, i => {
            int index0 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim13 / dim12 % dim11;
            int index12 = i / dim13 % dim12;
            int index13 = i % dim13;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13}.", nameof(collection));

        T[,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim13 / dim12 % dim11;
            int index12 = i / dim13 % dim12;
            int index13 = i % dim13;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 13-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        int dim13 = array.GetLength(13);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim13 / dim12 % dim11;
            int index12 = i / dim13 % dim12;
            int index13 = i % dim13;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 10-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(array));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim10 / dim9 % dim8;
            int outindex9 = i / dim10 % dim9;
            int outindex10 = i % dim10;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 11-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 11-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11}.", nameof(array));

        T[,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim11 / dim10 % dim9;
            int outindex10 = i / dim11 % dim10;
            int outindex11 = i % dim11;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 12-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 12-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12}.", nameof(array));

        T[,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim12 / dim11 % dim10;
            int outindex11 = i / dim12 % dim11;
            int outindex12 = i % dim12;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 13-dimensional array into a 13-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 13-dimensional input array.</param>
    /// <returns>The reshaped 13-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13}.", nameof(array));

        T[,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim13 / dim12 % dim11;
            int outindex12 = i / dim13 % dim12;
            int outindex13 = i % dim13;
            int inindex1 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim13 / indim12 % indim11;
            int inindex12 = i / indim13 % indim12;
            int inindex13 = i % indim13;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/> -> <typeparamref name="T13"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/> -> <typeparamref name="T13"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="arg9">The argument no. 10.</param>
    /// <param name="arg10">The argument no. 11.</param>
    /// <param name="arg11">The argument no. 12.</param>
    /// <param name="arg12">The argument no. 13.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T13 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg9">The argument no. 10.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="arg10">The argument no. 11.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="arg11">The argument no. 12.</param>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="arg12">The argument no. 13.</param>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="arg13">The argument no. 14.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);

    /// <summary>
    /// Maps the given 15-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 15-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 15-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        int dim13 = array.GetLength(13);
        int dim14 = array.GetLength(14);
        U[,,,,,,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14, i => {
            int index0 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim14 / dim13 % dim12;
            int index13 = i / dim14 % dim13;
            int index14 = i % dim14;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14}.", nameof(collection));

        T[,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim14 / dim13 % dim12;
            int index13 = i / dim14 % dim13;
            int index14 = i % dim14;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 14-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        int dim13 = array.GetLength(13);
        int dim14 = array.GetLength(14);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim14 / dim13 % dim12;
            int index13 = i / dim14 % dim13;
            int index14 = i % dim14;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 10-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(array));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim10 / dim9 % dim8;
            int outindex9 = i / dim10 % dim9;
            int outindex10 = i % dim10;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 11-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 11-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11}.", nameof(array));

        T[,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim11 / dim10 % dim9;
            int outindex10 = i / dim11 % dim10;
            int outindex11 = i % dim11;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 12-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 12-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12}.", nameof(array));

        T[,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim12 / dim11 % dim10;
            int outindex11 = i / dim12 % dim11;
            int outindex12 = i % dim12;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 13-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 13-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13}.", nameof(array));

        T[,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim13 / dim12 % dim11;
            int outindex12 = i / dim13 % dim12;
            int outindex13 = i % dim13;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 14-dimensional array into a 14-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 14-dimensional input array.</param>
    /// <returns>The reshaped 14-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14}.", nameof(array));

        T[,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim14 / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim14 / dim13 / dim12 % dim11;
            int outindex12 = i / dim14 / dim13 % dim12;
            int outindex13 = i / dim14 % dim13;
            int outindex14 = i % dim14;
            int inindex1 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim14 / indim13 % indim12;
            int inindex13 = i / indim14 % indim13;
            int inindex14 = i % indim14;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13, outindex14] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/> -> <typeparamref name="T14"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/>, <typeparamref name="T14"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/> -> <typeparamref name="T14"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="arg9">The argument no. 10.</param>
    /// <param name="arg10">The argument no. 11.</param>
    /// <param name="arg11">The argument no. 12.</param>
    /// <param name="arg12">The argument no. 13.</param>
    /// <param name="arg13">The argument no. 14.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T14 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/>, <typeparamref name="T14"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg9">The argument no. 10.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="arg10">The argument no. 11.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="arg11">The argument no. 12.</param>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="arg12">The argument no. 13.</param>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="arg13">The argument no. 14.</param>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="arg14">The argument no. 15.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);

    /// <summary>
    /// Maps the given 16-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 16-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 16-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        int dim13 = array.GetLength(13);
        int dim14 = array.GetLength(14);
        int dim15 = array.GetLength(15);
        U[,,,,,,,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14, dim15];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15, i => {
            int index0 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim15 / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim15 / dim14 / dim13 % dim12;
            int index13 = i / dim15 / dim14 % dim13;
            int index14 = i / dim15 % dim14;
            int index15 = i % dim15;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14, index15] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14, index15]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14, int dim15)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14} x {dim15}.", nameof(collection));

        T[,,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14, dim15];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim15 / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim15 / dim14 / dim13 % dim12;
            int index13 = i / dim15 / dim14 % dim13;
            int index14 = i / dim15 % dim14;
            int index15 = i % dim15;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14, index15] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 15-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        int dim13 = array.GetLength(13);
        int dim14 = array.GetLength(14);
        int dim15 = array.GetLength(15);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim15 / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim15 / dim14 / dim13 % dim12;
            int index13 = i / dim15 / dim14 % dim13;
            int index14 = i / dim15 % dim14;
            int index15 = i % dim15;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14, index15];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 10-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(array));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim10 / dim9 % dim8;
            int outindex9 = i / dim10 % dim9;
            int outindex10 = i % dim10;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 11-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 11-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11}.", nameof(array));

        T[,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim11 / dim10 % dim9;
            int outindex10 = i / dim11 % dim10;
            int outindex11 = i % dim11;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 12-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 12-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12}.", nameof(array));

        T[,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim12 / dim11 % dim10;
            int outindex11 = i / dim12 % dim11;
            int outindex12 = i % dim12;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 13-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 13-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13}.", nameof(array));

        T[,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim13 / dim12 % dim11;
            int outindex12 = i / dim13 % dim12;
            int outindex13 = i % dim13;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 14-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 14-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14}.", nameof(array));

        T[,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim14 / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim14 / dim13 / dim12 % dim11;
            int outindex12 = i / dim14 / dim13 % dim12;
            int outindex13 = i / dim14 % dim13;
            int outindex14 = i % dim14;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13, outindex14] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 15-dimensional array into a 15-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 15-dimensional input array.</param>
    /// <returns>The reshaped 15-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14, int dim15)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14} x {dim15}.", nameof(array));

        T[,,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14, dim15];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim15 / dim14 / dim13 / dim12 % dim11;
            int outindex12 = i / dim15 / dim14 / dim13 % dim12;
            int outindex13 = i / dim15 / dim14 % dim13;
            int outindex14 = i / dim15 % dim14;
            int outindex15 = i % dim15;
            int inindex1 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim15 / indim14 % indim13;
            int inindex14 = i / indim15 % indim14;
            int inindex15 = i % indim15;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13, outindex14, outindex15] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/>, <typeparamref name="T14"/> -> <typeparamref name="T15"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/>, <typeparamref name="T14"/>, <typeparamref name="T15"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, void>)pointer;

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/>, <typeparamref name="T14"/> -> <typeparamref name="T15"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="arg9">The argument no. 10.</param>
    /// <param name="arg10">The argument no. 11.</param>
    /// <param name="arg11">The argument no. 12.</param>
    /// <param name="arg12">The argument no. 13.</param>
    /// <param name="arg13">The argument no. 14.</param>
    /// <param name="arg14">The argument no. 15.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T15 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/>, <typeparamref name="T10"/>, <typeparamref name="T11"/>, <typeparamref name="T12"/>, <typeparamref name="T13"/>, <typeparamref name="T14"/>, <typeparamref name="T15"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg9">The argument no. 10.</param>
    /// <typeparam name="T10">The generic type parameter <typeparamref name="T10"/>.</typeparam>
    /// <param name="arg10">The argument no. 11.</param>
    /// <typeparam name="T11">The generic type parameter <typeparamref name="T11"/>.</typeparam>
    /// <param name="arg11">The argument no. 12.</param>
    /// <typeparam name="T12">The generic type parameter <typeparamref name="T12"/>.</typeparam>
    /// <param name="arg12">The argument no. 13.</param>
    /// <typeparam name="T13">The generic type parameter <typeparamref name="T13"/>.</typeparam>
    /// <param name="arg13">The argument no. 14.</param>
    /// <typeparam name="T14">The generic type parameter <typeparamref name="T14"/>.</typeparam>
    /// <param name="arg14">The argument no. 15.</param>
    /// <typeparam name="T15">The generic type parameter <typeparamref name="T15"/>.</typeparam>
    /// <param name="arg15">The argument no. 16.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);

    /// <summary>
    /// Maps the given 17-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 17-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 17-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        int dim13 = array.GetLength(13);
        int dim14 = array.GetLength(14);
        int dim15 = array.GetLength(15);
        int dim16 = array.GetLength(16);
        U[,,,,,,,,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14, dim15, dim16];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15 * dim16, i => {
            int index0 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim16 / dim15 / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim16 / dim15 / dim14 / dim13 % dim12;
            int index13 = i / dim16 / dim15 / dim14 % dim13;
            int index14 = i / dim16 / dim15 % dim14;
            int index15 = i / dim16 % dim15;
            int index16 = i % dim16;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14, index15, index16] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14, index15, index16]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14, int dim15, int dim16)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15 * dim16;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14} x {dim15} x {dim16}.", nameof(collection));

        T[,,,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14, dim15, dim16];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim16 / dim15 / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim16 / dim15 / dim14 / dim13 % dim12;
            int index13 = i / dim16 / dim15 / dim14 % dim13;
            int index14 = i / dim16 / dim15 % dim14;
            int index15 = i / dim16 % dim15;
            int index16 = i % dim16;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14, index15, index16] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 16-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,,,,,,,,] array)
    {
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        int dim11 = array.GetLength(11);
        int dim12 = array.GetLength(12);
        int dim13 = array.GetLength(13);
        int dim14 = array.GetLength(14);
        int dim15 = array.GetLength(15);
        int dim16 = array.GetLength(16);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15 * dim16];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int index9 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int index10 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int index11 = i / dim16 / dim15 / dim14 / dim13 / dim12 % dim11;
            int index12 = i / dim16 / dim15 / dim14 / dim13 % dim12;
            int index13 = i / dim16 / dim15 / dim14 % dim13;
            int index14 = i / dim16 / dim15 % dim14;
            int index15 = i / dim16 % dim15;
            int index16 = i % dim16;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10, index11, index12, index13, index14, index15, index16];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 10-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(array));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim10 / dim9 % dim8;
            int outindex9 = i / dim10 % dim9;
            int outindex10 = i % dim10;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 11-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 11-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11}.", nameof(array));

        T[,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim11 / dim10 % dim9;
            int outindex10 = i / dim11 % dim10;
            int outindex11 = i % dim11;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 12-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 12-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12}.", nameof(array));

        T[,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim12 / dim11 % dim10;
            int outindex11 = i / dim12 % dim11;
            int outindex12 = i % dim12;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 13-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 13-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13}.", nameof(array));

        T[,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim13 / dim12 % dim11;
            int outindex12 = i / dim13 % dim12;
            int outindex13 = i % dim13;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 14-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 14-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14}.", nameof(array));

        T[,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim14 / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim14 / dim13 / dim12 % dim11;
            int outindex12 = i / dim14 / dim13 % dim12;
            int outindex13 = i / dim14 % dim13;
            int outindex14 = i % dim14;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13, outindex14] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 15-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 15-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14, int dim15)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14} x {dim15}.", nameof(array));

        T[,,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14, dim15];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim15 / dim14 / dim13 / dim12 % dim11;
            int outindex12 = i / dim15 / dim14 / dim13 % dim12;
            int outindex13 = i / dim15 / dim14 % dim13;
            int outindex14 = i / dim15 % dim14;
            int outindex15 = i % dim15;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13, outindex14, outindex15] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 16-dimensional array into a 16-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 16-dimensional input array.</param>
    /// <returns>The reshaped 16-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10, int dim11, int dim12, int dim13, int dim14, int dim15, int dim16)
    {
        int indim1 = array.GetLength(1);
        int indim2 = array.GetLength(2);
        int indim3 = array.GetLength(3);
        int indim4 = array.GetLength(4);
        int indim5 = array.GetLength(5);
        int indim6 = array.GetLength(6);
        int indim7 = array.GetLength(7);
        int indim8 = array.GetLength(8);
        int indim9 = array.GetLength(9);
        int indim10 = array.GetLength(10);
        int indim11 = array.GetLength(11);
        int indim12 = array.GetLength(12);
        int indim13 = array.GetLength(13);
        int indim14 = array.GetLength(14);
        int indim15 = array.GetLength(15);
        int indim16 = array.GetLength(16);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10 * indim11 * indim12 * indim13 * indim14 * indim15 * indim16;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10 * dim11 * dim12 * dim13 * dim14 * dim15 * dim16;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10} x {indim11} x {indim12} x {indim13} x {indim14} x {indim15} x {indim16}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10} x {dim11} x {dim12} x {dim13} x {dim14} x {dim15} x {dim16}.", nameof(array));

        T[,,,,,,,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10, dim11, dim12, dim13, dim14, dim15, dim16];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 / dim9 % dim8;
            int outindex9 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 / dim10 % dim9;
            int outindex10 = i / dim16 / dim15 / dim14 / dim13 / dim12 / dim11 % dim10;
            int outindex11 = i / dim16 / dim15 / dim14 / dim13 / dim12 % dim11;
            int outindex12 = i / dim16 / dim15 / dim14 / dim13 % dim12;
            int outindex13 = i / dim16 / dim15 / dim14 % dim13;
            int outindex14 = i / dim16 / dim15 % dim14;
            int outindex15 = i / dim16 % dim15;
            int outindex16 = i % dim16;
            int inindex1 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 / indim9 % indim8;
            int inindex9 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 / indim10 % indim9;
            int inindex10 = i / indim16 / indim15 / indim14 / indim13 / indim12 / indim11 % indim10;
            int inindex11 = i / indim16 / indim15 / indim14 / indim13 / indim12 % indim11;
            int inindex12 = i / indim16 / indim15 / indim14 / indim13 % indim12;
            int inindex13 = i / indim16 / indim15 / indim14 % indim13;
            int inindex14 = i / indim16 / indim15 % indim14;
            int inindex15 = i / indim16 % indim15;
            int inindex16 = i % indim16;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10, outindex11, outindex12, outindex13, outindex14, outindex15, outindex16] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10, inindex11, inindex12, inindex13, inindex14, inindex15, inindex16];
        });

        return reshaped;
    }
}

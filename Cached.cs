
////////////////////////////////////////////////////// AUTOGENERATED //////////////////////////////////////////////////////
// WARNING: All code changes to this file will be lost upon regeneration.                                                //
// Autogenerated on 2022-03-11 16:33:05:939488                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System;

namespace Unknown6656.Generics;


public static partial class FuncCache
{
    // public const string DefaultDictionaryCacheName = nameof(DelayedCachedDictionary<,>);

    public static Type DefaultDictionaryCacheType { get; } = typeof(DelayedCachedDictionary<,>);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TValue>
    where TDict : IDictionary<TKey0, TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0] => Invoke(key0);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0)
    {
        var key = (key0);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TValue>(Func<TKey0, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TValue>(_FuncCache<TDict, TKey0, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TValue>
    : _FuncCache<DelayedCachedDictionary<TKey0, TValue>, TKey0, TValue>
{
    public FuncCache(Func<TKey0, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TValue>(Func<TKey0, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TValue> Cached<TKey0, TValue>(this Func<TKey0, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1] => Invoke(key0, key1);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1)
    {
        var key = (key0, key1);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TValue>(Func<TKey0, TKey1, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TValue>(_FuncCache<TDict, TKey0, TKey1, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1), TValue>, TKey0, TKey1, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TValue>(Func<TKey0, TKey1, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TValue> Cached<TKey0, TKey1, TValue>(this Func<TKey0, TKey1, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2] => Invoke(key0, key1, key2);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2)
    {
        var key = (key0, key1, key2);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TValue>(Func<TKey0, TKey1, TKey2, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2), TValue>, TKey0, TKey1, TKey2, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TValue>(Func<TKey0, TKey1, TKey2, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TValue> Cached<TKey0, TKey1, TKey2, TValue>(this Func<TKey0, TKey1, TKey2, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3] => Invoke(key0, key1, key2, key3);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3)
    {
        var key = (key0, key1, key2, key3);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3), TValue>, TKey0, TKey1, TKey2, TKey3, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4] => Invoke(key0, key1, key2, key3, key4);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4)
    {
        var key = (key0, key1, key2, key3, key4);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5] => Invoke(key0, key1, key2, key3, key4, key5);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5)
    {
        var key = (key0, key1, key2, key3, key4, key5);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6] => Invoke(key0, key1, key2, key3, key4, key5, key6);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <param name="key8">The function argument no. 8.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TKey9">The generic parameter type of argument no. 9.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <param name="key8">The function argument no. 8.</typeparam>
    /// <param name="key9">The function argument no. 9.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8, key9);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} x {typeof(TKey9)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TKey9">The generic parameter type of argument no. 9.</typeparam>
/// <typeparam name="TKey10">The generic parameter type of argument no. 10.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <param name="key8">The function argument no. 8.</typeparam>
    /// <param name="key9">The function argument no. 9.</typeparam>
    /// <param name="key10">The function argument no. 10.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} x {typeof(TKey9)} x {typeof(TKey10)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TKey9">The generic parameter type of argument no. 9.</typeparam>
/// <typeparam name="TKey10">The generic parameter type of argument no. 10.</typeparam>
/// <typeparam name="TKey11">The generic parameter type of argument no. 11.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <param name="key8">The function argument no. 8.</typeparam>
    /// <param name="key9">The function argument no. 9.</typeparam>
    /// <param name="key10">The function argument no. 10.</typeparam>
    /// <param name="key11">The function argument no. 11.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} x {typeof(TKey9)} x {typeof(TKey10)} x {typeof(TKey11)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TKey9">The generic parameter type of argument no. 9.</typeparam>
/// <typeparam name="TKey10">The generic parameter type of argument no. 10.</typeparam>
/// <typeparam name="TKey11">The generic parameter type of argument no. 11.</typeparam>
/// <typeparam name="TKey12">The generic parameter type of argument no. 12.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <param name="key8">The function argument no. 8.</typeparam>
    /// <param name="key9">The function argument no. 9.</typeparam>
    /// <param name="key10">The function argument no. 10.</typeparam>
    /// <param name="key11">The function argument no. 11.</typeparam>
    /// <param name="key12">The function argument no. 12.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} x {typeof(TKey9)} x {typeof(TKey10)} x {typeof(TKey11)} x {typeof(TKey12)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TKey9">The generic parameter type of argument no. 9.</typeparam>
/// <typeparam name="TKey10">The generic parameter type of argument no. 10.</typeparam>
/// <typeparam name="TKey11">The generic parameter type of argument no. 11.</typeparam>
/// <typeparam name="TKey12">The generic parameter type of argument no. 12.</typeparam>
/// <typeparam name="TKey13">The generic parameter type of argument no. 13.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <param name="key8">The function argument no. 8.</typeparam>
    /// <param name="key9">The function argument no. 9.</typeparam>
    /// <param name="key10">The function argument no. 10.</typeparam>
    /// <param name="key11">The function argument no. 11.</typeparam>
    /// <param name="key12">The function argument no. 12.</typeparam>
    /// <param name="key13">The function argument no. 13.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} x {typeof(TKey9)} x {typeof(TKey10)} x {typeof(TKey11)} x {typeof(TKey12)} x {typeof(TKey13)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TKey9">The generic parameter type of argument no. 9.</typeparam>
/// <typeparam name="TKey10">The generic parameter type of argument no. 10.</typeparam>
/// <typeparam name="TKey11">The generic parameter type of argument no. 11.</typeparam>
/// <typeparam name="TKey12">The generic parameter type of argument no. 12.</typeparam>
/// <typeparam name="TKey13">The generic parameter type of argument no. 13.</typeparam>
/// <typeparam name="TKey14">The generic parameter type of argument no. 14.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13, TKey14 key14), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13, TKey14 key14] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <param name="key8">The function argument no. 8.</typeparam>
    /// <param name="key9">The function argument no. 9.</typeparam>
    /// <param name="key10">The function argument no. 10.</typeparam>
    /// <param name="key11">The function argument no. 11.</typeparam>
    /// <param name="key12">The function argument no. 12.</typeparam>
    /// <param name="key13">The function argument no. 13.</typeparam>
    /// <param name="key14">The function argument no. 14.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13, TKey14 key14)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} x {typeof(TKey9)} x {typeof(TKey10)} x {typeof(TKey11)} x {typeof(TKey12)} x {typeof(TKey13)} x {typeof(TKey14)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13, TKey14 key14), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TValue> function) => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TKey9">The generic parameter type of argument no. 9.</typeparam>
/// <typeparam name="TKey10">The generic parameter type of argument no. 10.</typeparam>
/// <typeparam name="TKey11">The generic parameter type of argument no. 11.</typeparam>
/// <typeparam name="TKey12">The generic parameter type of argument no. 12.</typeparam>
/// <typeparam name="TKey13">The generic parameter type of argument no. 13.</typeparam>
/// <typeparam name="TKey14">The generic parameter type of argument no. 14.</typeparam>
/// <typeparam name="TKey15">The generic parameter type of argument no. 15.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13, TKey14 key14, TKey15 key15), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13, TKey14 key14, TKey15 key15] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14, key15);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</typeparam>
    /// <param name="key1">The function argument no. 1.</typeparam>
    /// <param name="key2">The function argument no. 2.</typeparam>
    /// <param name="key3">The function argument no. 3.</typeparam>
    /// <param name="key4">The function argument no. 4.</typeparam>
    /// <param name="key5">The function argument no. 5.</typeparam>
    /// <param name="key6">The function argument no. 6.</typeparam>
    /// <param name="key7">The function argument no. 7.</typeparam>
    /// <param name="key8">The function argument no. 8.</typeparam>
    /// <param name="key9">The function argument no. 9.</typeparam>
    /// <param name="key10">The function argument no. 10.</typeparam>
    /// <param name="key11">The function argument no. 11.</typeparam>
    /// <param name="key12">The function argument no. 12.</typeparam>
    /// <param name="key13">The function argument no. 13.</typeparam>
    /// <param name="key14">The function argument no. 14.</typeparam>
    /// <param name="key15">The function argument no. 15.</typeparam>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13, TKey14 key14, TKey15 key15)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14, key15);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10, key11, key12, key13, key14, key15);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} x {typeof(TKey9)} x {typeof(TKey10)} x {typeof(TKey11)} x {typeof(TKey12)} x {typeof(TKey13)} x {typeof(TKey14)} x {typeof(TKey15)} -> {typeof(TValue)}";

    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> function) => new(function);

    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> cached) => cached.Cache;

    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8, TKey9 key9, TKey10 key10, TKey11 key11, TKey12 key12, TKey13 key13, TKey14 key14, TKey15 key15), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue>
{
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> function)
        : base(function)
    {
    }

    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> function) => new(function);
}

public static partial class FuncCache
{
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TKey10, TKey11, TKey12, TKey13, TKey14, TKey15, TValue> function) => new(function);
}


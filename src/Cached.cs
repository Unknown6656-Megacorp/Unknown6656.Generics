
////////////////////////////////////////////////////// AUTOGENERATED //////////////////////////////////////////////////////
// WARNING: All code changes to this file will be lost upon regeneration.                                                //
// Autogenerated on 2024-07-28 11:00:22:069429                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System;

namespace Unknown6656.Generics;


/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
public static partial class FuncCache
{
    /// <summary>
    /// Returns the <see cref="Type"/> information for the default dictionary datastructure, which is used for the generalized function caches.
    /// <para/>
    /// The type defaults to <see cref="DelayedCachedDictionary{K,V}"/>.
    /// <para/>
    /// If you want to change this type, you either have to provide a custom Dictionary to the <typeparamref name="TDict"/> generic parameter of the type <see cref="_FuncCache{TDict, TKey0, Value}"/>.
    /// Otherwise, you'll have to recompile "Unknown6656.<see cref="Unknown6656.Generics"/>" with your custom implementation.
    /// Please refer to <a href="https://github.com/Unknown6656-Megacorp/Unknown6656.Generics/blob/master/Cached.tt">Cached.tt</a>.
    /// </summary>
    public static Type DefaultDictionaryCacheType { get; } = typeof(DelayedCachedDictionary<,>);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TValue>
    where TDict : IDictionary<TKey0, TValue>, new()
    where TKey0 : notnull
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0] => Invoke(key0);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0)
    {
        var key = (key0);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TValue}._FuncCache(Func{TKey0, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TValue>(Func<TKey0, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TValue>(_FuncCache<TDict, TKey0, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TValue>
    : _FuncCache<DelayedCachedDictionary<TKey0, TValue>, TKey0, TValue>
    where TKey0 : notnull
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TValue}._FuncCache(Func{TKey0, TValue})"/>
    public FuncCache(Func<TKey0, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TValue}._FuncCache(delegate*{TKey0, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TValue}.FuncCache(Func{TKey0, TValue})"/>
    public static implicit operator FuncCache<TKey0, TValue>(Func<TKey0, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TValue}.FuncCache(Func{TKey0, TValue})"/>
    public static FuncCache<TKey0, TValue> Cached<TKey0, TValue>(this Func<TKey0, TValue> function)
        where TKey0 : notnull => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1] => Invoke(key0, key1);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <param name="key1">The function argument no. 1.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1)
    {
        var key = (key0, key1);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TValue}._FuncCache(Func{TKey0, TKey1, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TValue>(Func<TKey0, TKey1, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TKey1, TValue>(_FuncCache<TDict, TKey0, TKey1, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1), TValue>, TKey0, TKey1, TValue>
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TValue}._FuncCache(Func{TKey0, TKey1, TValue})"/>
    public FuncCache(Func<TKey0, TKey1, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TValue}._FuncCache(delegate*{TKey0, TKey1, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TKey1, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TValue}.FuncCache(Func{TKey0, TKey1, TValue})"/>
    public static implicit operator FuncCache<TKey0, TKey1, TValue>(Func<TKey0, TKey1, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TValue}.FuncCache(Func{TKey0, TKey1, TValue})"/>
    public static FuncCache<TKey0, TKey1, TValue> Cached<TKey0, TKey1, TValue>(this Func<TKey0, TKey1, TValue> function)
        => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2] => Invoke(key0, key1, key2);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <param name="key1">The function argument no. 1.</param>
    /// <param name="key2">The function argument no. 2.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2)
    {
        var key = (key0, key1, key2);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TValue>(Func<TKey0, TKey1, TKey2, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TKey1, TKey2, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2), TValue>, TKey0, TKey1, TKey2, TValue>
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TValue})"/>
    public FuncCache(Func<TKey0, TKey1, TKey2, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TValue}._FuncCache(delegate*{TKey0, TKey1, TKey2, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TValue})"/>
    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TValue>(Func<TKey0, TKey1, TKey2, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TValue})"/>
    public static FuncCache<TKey0, TKey1, TKey2, TValue> Cached<TKey0, TKey1, TKey2, TValue>(this Func<TKey0, TKey1, TKey2, TValue> function)
        => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3] => Invoke(key0, key1, key2, key3);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <param name="key1">The function argument no. 1.</param>
    /// <param name="key2">The function argument no. 2.</param>
    /// <param name="key3">The function argument no. 3.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3)
    {
        var key = (key0, key1, key2, key3);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3), TValue>, TKey0, TKey1, TKey2, TKey3, TValue>
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TValue})"/>
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TValue}._FuncCache(delegate*{TKey0, TKey1, TKey2, TKey3, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TValue})"/>
    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TValue})"/>
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TValue> function)
        => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4] => Invoke(key0, key1, key2, key3, key4);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <param name="key1">The function argument no. 1.</param>
    /// <param name="key2">The function argument no. 2.</param>
    /// <param name="key3">The function argument no. 3.</param>
    /// <param name="key4">The function argument no. 4.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4)
    {
        var key = (key0, key1, key2, key3, key4);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TValue>
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TValue})"/>
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TValue}._FuncCache(delegate*{TKey0, TKey1, TKey2, TKey3, TKey4, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TValue})"/>
    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TValue})"/>
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TValue> function)
        => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5] => Invoke(key0, key1, key2, key3, key4, key5);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <param name="key1">The function argument no. 1.</param>
    /// <param name="key2">The function argument no. 2.</param>
    /// <param name="key3">The function argument no. 3.</param>
    /// <param name="key4">The function argument no. 4.</param>
    /// <param name="key5">The function argument no. 5.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5)
    {
        var key = (key0, key1, key2, key3, key4, key5);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue})"/>
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue}._FuncCache(delegate*{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue})"/>
    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue})"/>
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TValue> function)
        => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6] => Invoke(key0, key1, key2, key3, key4, key5, key6);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <param name="key1">The function argument no. 1.</param>
    /// <param name="key2">The function argument no. 2.</param>
    /// <param name="key3">The function argument no. 3.</param>
    /// <param name="key4">The function argument no. 4.</param>
    /// <param name="key5">The function argument no. 5.</param>
    /// <param name="key6">The function argument no. 6.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue})"/>
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue}._FuncCache(delegate*{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue})"/>
    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue})"/>
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue> function)
        => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <param name="key1">The function argument no. 1.</param>
    /// <param name="key2">The function argument no. 2.</param>
    /// <param name="key3">The function argument no. 3.</param>
    /// <param name="key4">The function argument no. 4.</param>
    /// <param name="key5">The function argument no. 5.</param>
    /// <param name="key6">The function argument no. 6.</param>
    /// <param name="key7">The function argument no. 7.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue})"/>
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue}._FuncCache(delegate*{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue})"/>
    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue})"/>
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue> function)
        => new(function);
}

/// <summary>
/// Represents a generic function cache, which internally stores the results of function executions and recalls them when needed.
/// The cache essentially turns a given function into it's lazy variant, which only once invokes the underlying function for each given parameter.
/// All subsequent calls with the same parameters are replaced by look-ups using an dictionary.
/// </summary>
/// <typeparam name="TDict">The internal cache dictionary parameter type.</typeparam>
/// <typeparam name="TKey0">The generic parameter type of argument no. 0.</typeparam>
/// <typeparam name="TKey1">The generic parameter type of argument no. 1.</typeparam>
/// <typeparam name="TKey2">The generic parameter type of argument no. 2.</typeparam>
/// <typeparam name="TKey3">The generic parameter type of argument no. 3.</typeparam>
/// <typeparam name="TKey4">The generic parameter type of argument no. 4.</typeparam>
/// <typeparam name="TKey5">The generic parameter type of argument no. 5.</typeparam>
/// <typeparam name="TKey6">The generic parameter type of argument no. 6.</typeparam>
/// <typeparam name="TKey7">The generic parameter type of argument no. 7.</typeparam>
/// <typeparam name="TKey8">The generic parameter type of argument no. 8.</typeparam>
/// <typeparam name="TValue">The function's generic return type.</typeparam>
public class _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>
    where TDict : IDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8), TValue>, new()
{
    /// <summary>
    /// The function to be cached.
    /// </summary>
    public Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> Function { get; }

    /// <summary>
    /// The underlying cache.
    /// </summary>
    public TDict Cache { get; } = new();

    /// <summary>
    /// The cache's size. This is <b>not</b> its binary size (i.e. size in bytes), but rather the count of stored cache entries.
    /// </summary>
    public int CacheSize => Cache.Count;

    /// <inheritdoc cref="Invoke"/>
    public TValue this[TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8] => Invoke(key0, key1, key2, key3, key4, key5, key6, key7, key8);


    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function">The function to be cached.</param>
    public _FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function) => Function = function;

    /// <summary>
    /// Creates a new function cache for the given function.
    /// </summary>
    /// <param name="function_pointer">The function to which the given pointer is pointing.</param>
    public unsafe _FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function_pointer)
        : this(LINQ.ToFunction(function_pointer))
    {
    }

    /// <summary>
    /// Invokes the underlying function.
    /// </summary>
    /// <param name="key0">The function argument no. 0.</param>
    /// <param name="key1">The function argument no. 1.</param>
    /// <param name="key2">The function argument no. 2.</param>
    /// <param name="key3">The function argument no. 3.</param>
    /// <param name="key4">The function argument no. 4.</param>
    /// <param name="key5">The function argument no. 5.</param>
    /// <param name="key6">The function argument no. 6.</param>
    /// <param name="key7">The function argument no. 7.</param>
    /// <param name="key8">The function argument no. 8.</param>
    /// <returns>The function's return value. This value will be fetched from the internal look-up table if the function has already once been called with the exact same arguments.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Invoke(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8)
    {
        var key = (key0, key1, key2, key3, key4, key5, key6, key7, key8);

        if (!Cache.TryGetValue(key, out TValue? value))
            Cache[key] = value = Function(key0, key1, key2, key3, key4, key5, key6, key7, key8);

        return value;
    }

    /// <summary>
    /// Clears the cache by removing all entries.
    /// </summary>
    public void ClearCache() => Cache.Clear();

    /// <inheritdoc/>
    public override string ToString() => $"[Cached: {CacheSize} entries] {typeof(TKey0)} x {typeof(TKey1)} x {typeof(TKey2)} x {typeof(TKey3)} x {typeof(TKey4)} x {typeof(TKey5)} x {typeof(TKey6)} x {typeof(TKey7)} x {typeof(TKey8)} -> {typeof(TValue)}";

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue})"/>
    public static implicit operator _FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function) => new(function);

    /// <inheritdoc cref="Cache"/>
    /// <summary>
    /// Returns the underlying cache of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator TDict(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> cached) => cached.Cache;

    /// <inheritdoc cref="Function"/>
    /// <summary>
    /// Returns the underlying function of the given cached function.
    /// </summary>
    /// <param name="cached">The cached function.</param>
    public static implicit operator Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(_FuncCache<TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> cached) => cached.Function;
}

/// <inheritdoc/>
public class FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>
    : _FuncCache<DelayedCachedDictionary<(TKey0 key0, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, TKey8 key8), TValue>, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>
{
    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue}._FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue})"/>
    public FuncCache(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function)
        : base(function)
    {
    }

    /// <inheritdoc cref="_FuncCache{TDict, TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue}._FuncCache(delegate*{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue})"/>
    public unsafe FuncCache(delegate*<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function_pointer)
        : base(function_pointer)
    {
    }

    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue})"/>
    public static implicit operator FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function) => new(function);
}

public static partial class FuncCache
{
    /// <inheritdoc cref="FuncCache{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue}.FuncCache(Func{TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue})"/>
    public static FuncCache<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> Cached<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(this Func<TKey0, TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue> function)
        => new(function);
}


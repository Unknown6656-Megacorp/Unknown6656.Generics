////////////////////////////////////////////////////// AUTOGENERATED //////////////////////////////////////////////////////
// WARNING: All code changes to this file will be lost upon regeneration.                                                //
// Autogenerated on 2024-07-28 11:00:21:614376                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;
using System;

namespace Unknown6656.Generics;


public static unsafe partial class LINQ
{

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1) Join<T0, T1>(this T0 t0, T1 t1) =>
        (t0, t1);

    /// <summary>
    /// Creates a new array with exactly 2 elements from the given 2-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 2-tuple.</param>
    /// <returns>The array (Length = 2) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1) tuple) =>
        new[] { tuple.t0, tuple.t1 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1) Apply<T, U>(this (T e0, T e1) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this (T0 left, (T1, T2) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this T0 left, (T1, T2) right) =>
        (left, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this ((T0, T1) left, T2 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this (T0, T1) left, T2 right) =>
        (left.Item1, left.Item2, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2) Join<T0, T1, T2>(this T0 t0, T1 t1, T2 t2) =>
        (t0, t1, t2);

    /// <summary>
    /// Creates a new array with exactly 3 elements from the given 3-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 3-tuple.</param>
    /// <returns>The array (Length = 3) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2) Apply<T, U>(this (T e0, T e1, T e2) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this (T0 left, (T1, T2, T3) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this T0 left, (T1, T2, T3) right) =>
        (left, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this ((T0, T1) left, (T2, T3) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this (T0, T1) left, (T2, T3) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this ((T0, T1, T2) left, T3 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this (T0, T1, T2) left, T3 right) =>
        (left.Item1, left.Item2, left.Item3, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3) Join<T0, T1, T2, T3>(this T0 t0, T1 t1, T2 t2, T3 t3) =>
        (t0, t1, t2, t3);

    /// <summary>
    /// Creates a new array with exactly 4 elements from the given 4-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 4-tuple.</param>
    /// <returns>The array (Length = 4) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3) Apply<T, U>(this (T e0, T e1, T e2, T e3) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this (T0 left, (T1, T2, T3, T4) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this T0 left, (T1, T2, T3, T4) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this ((T0, T1) left, (T2, T3, T4) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this (T0, T1) left, (T2, T3, T4) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this ((T0, T1, T2) left, (T3, T4) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this (T0, T1, T2) left, (T3, T4) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this ((T0, T1, T2, T3) left, T4 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this (T0, T1, T2, T3) left, T4 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4) Join<T0, T1, T2, T3, T4>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4) =>
        (t0, t1, t2, t3, t4);

    /// <summary>
    /// Creates a new array with exactly 5 elements from the given 5-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 5-tuple.</param>
    /// <returns>The array (Length = 5) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0 left, (T1, T2, T3, T4, T5) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this T0 left, (T1, T2, T3, T4, T5) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this ((T0, T1) left, (T2, T3, T4, T5) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0, T1) left, (T2, T3, T4, T5) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this ((T0, T1, T2) left, (T3, T4, T5) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0, T1, T2) left, (T3, T4, T5) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this ((T0, T1, T2, T3) left, (T4, T5) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0, T1, T2, T3) left, (T4, T5) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this ((T0, T1, T2, T3, T4) left, T5 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this (T0, T1, T2, T3, T4) left, T5 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5) Join<T0, T1, T2, T3, T4, T5>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) =>
        (t0, t1, t2, t3, t4, t5);

    /// <summary>
    /// Creates a new array with exactly 6 elements from the given 6-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 6-tuple.</param>
    /// <returns>The array (Length = 6) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0 left, (T1, T2, T3, T4, T5, T6) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this T0 left, (T1, T2, T3, T4, T5, T6) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1) left, (T2, T3, T4, T5, T6) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1) left, (T2, T3, T4, T5, T6) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1, T2) left, (T3, T4, T5, T6) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1, T2) left, (T3, T4, T5, T6) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1, T2, T3) left, (T4, T5, T6) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1, T2, T3) left, (T4, T5, T6) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1, T2, T3, T4) left, (T5, T6) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1, T2, T3, T4) left, (T5, T6) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this ((T0, T1, T2, T3, T4, T5) left, T6 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this (T0, T1, T2, T3, T4, T5) left, T6 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6) Join<T0, T1, T2, T3, T4, T5, T6>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) =>
        (t0, t1, t2, t3, t4, t5, t6);

    /// <summary>
    /// Creates a new array with exactly 7 elements from the given 7-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 7-tuple.</param>
    /// <returns>The array (Length = 7) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this T0 left, (T1, T2, T3, T4, T5, T6, T7) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this ((T0, T1, T2, T3, T4, T5, T6) left, T7 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this (T0, T1, T2, T3, T4, T5, T6) left, T7 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7) Join<T0, T1, T2, T3, T4, T5, T6, T7>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) =>
        (t0, t1, t2, t3, t4, t5, t6, t7);

    /// <summary>
    /// Creates a new array with exactly 8 elements from the given 8-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 8-tuple.</param>
    /// <returns>The array (Length = 8) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, T8 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, T8 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8);

    /// <summary>
    /// Creates a new array with exactly 9 elements from the given 9-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 9-tuple.</param>
    /// <returns>The array (Length = 9) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8));

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8, tuple.right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this T0 left, (T1, T2, T3, T4, T5, T6, T7, T8, T9) right) =>
        (left, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8, right.Item9);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7, tuple.right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1) left, (T2, T3, T4, T5, T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7, right.Item8);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6, tuple.right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2) left, (T3, T4, T5, T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6, right.Item7);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5, tuple.right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3) left, (T4, T5, T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5, right.Item6);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4, tuple.right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4) left, (T5, T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, right.Item1, right.Item2, right.Item3, right.Item4, right.Item5);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3, tuple.right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4, T5) left, (T6, T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, right.Item1, right.Item2, right.Item3, right.Item4);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.right.Item1, tuple.right.Item2, tuple.right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4, T5, T6) left, (T7, T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, right.Item1, right.Item2, right.Item3);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9) right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.right.Item1, tuple.right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4, T5, T6, T7) left, (T8, T9) right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, right.Item1, right.Item2);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this ((T0, T1, T2, T3, T4, T5, T6, T7, T8) left, T9 right) tuple) =>
        (tuple.left.Item1, tuple.left.Item2, tuple.left.Item3, tuple.left.Item4, tuple.left.Item5, tuple.left.Item6, tuple.left.Item7, tuple.left.Item8, tuple.left.Item9, tuple.right);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this (T0, T1, T2, T3, T4, T5, T6, T7, T8) left, T9 right) =>
        (left.Item1, left.Item2, left.Item3, left.Item4, left.Item5, left.Item6, left.Item7, left.Item8, left.Item9, right);

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
    /// <param name="t0">The tuple element at position 1.</param>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/> for the argument <paramref name="t0"/>.</typeparam>
    /// <param name="t1">The tuple element at position 2.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/> for the argument <paramref name="t1"/>.</typeparam>
    /// <param name="t2">The tuple element at position 3.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/> for the argument <paramref name="t2"/>.</typeparam>
    /// <param name="t3">The tuple element at position 4.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/> for the argument <paramref name="t3"/>.</typeparam>
    /// <param name="t4">The tuple element at position 5.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/> for the argument <paramref name="t4"/>.</typeparam>
    /// <param name="t5">The tuple element at position 6.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/> for the argument <paramref name="t5"/>.</typeparam>
    /// <param name="t6">The tuple element at position 7.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/> for the argument <paramref name="t6"/>.</typeparam>
    /// <param name="t7">The tuple element at position 8.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/> for the argument <paramref name="t7"/>.</typeparam>
    /// <param name="t8">The tuple element at position 9.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/> for the argument <paramref name="t8"/>.</typeparam>
    /// <param name="t9">The tuple element at position 10.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/> for the argument <paramref name="t9"/>.</typeparam>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) Join<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(this T0 t0, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) =>
        (t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);

    /// <summary>
    /// Creates a new array with exactly 10 elements from the given 10-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A 10-tuple.</param>
    /// <returns>The array (Length = 10) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (T t0, T t1, T t2, T t3, T t4, T t5, T t6, T t7, T t8, T t9) tuple) =>
        new[] { tuple.t0, tuple.t1, tuple.t2, tuple.t3, tuple.t4, tuple.t5, tuple.t6, tuple.t7, tuple.t8, tuple.t9 };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (U e0, U e1, U e2, U e3, U e4, U e5, U e6, U e7, U e8, U e9) Apply<T, U>(this (T e0, T e1, T e2, T e3, T e4, T e5, T e6, T e7, T e8, T e9) x, Func<T, U> func) =>
        (func(x.e0), func(x.e1), func(x.e2), func(x.e3), func(x.e4), func(x.e5), func(x.e6), func(x.e7), func(x.e8), func(x.e9));

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// </summary>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<void> ToActionPointer(void* pointer) => (delegate*<void>)pointer;

    public static Action ToAction(delegate*<void> pointer) => () => pointer();

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <see langword="void"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction(void* pointer) => ToActionPointer(pointer)();

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    ///  -> <typeparamref name="T0"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0> ToFunctionPointer<T0>(void* pointer) =>
        (delegate*<T0>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, void> ToActionPointer<T0>(void* pointer) =>
        (delegate*<T0, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0> ToFunction<T0>(delegate*<T0> pointer) =>
        new(() => pointer());

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0> ToAction<T0>(delegate*<T0, void> pointer) =>
        new((arg0) => pointer(arg0));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    ///  -> <typeparamref name="T0"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T0 InvokeFunction<T0>(void* pointer) =>
        ToFunctionPointer<T0>(pointer)();

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0>(void* pointer, T0 arg0) =>
        ToActionPointer<T0>(pointer)(arg0);

    /// <summary>
    /// Maps the given 2-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 2-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,] Select<T, U>(this T[,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        U[,] result = new U[dim0, dim1];

        Parallel.For(0, dim0 * dim1, i => {
            int index0 = i / dim1;
            int index1 = i % dim1;

            result[index0, index1] = map(array[index0, index1]);
        });

        return result;
    }


    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/> -> <typeparamref name="T1"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1> ToFunctionPointer<T0, T1>(void* pointer) =>
        (delegate*<T0, T1>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, void> ToActionPointer<T0, T1>(void* pointer) =>
        (delegate*<T0, T1, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1> ToFunction<T0, T1>(delegate*<T0, T1> pointer) =>
        new((arg0) => pointer(arg0));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1> ToAction<T0, T1>(delegate*<T0, T1, void> pointer) =>
        new((arg0, arg1) => pointer(arg0, arg1));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/> -> <typeparamref name="T1"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T1 InvokeFunction<T0, T1>(void* pointer, T0 arg0) =>
        ToFunctionPointer<T0, T1>(pointer)(arg0);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1>(void* pointer, T0 arg0, T1 arg1) =>
        ToActionPointer<T0, T1>(pointer)(arg0, arg1);

    /// <summary>
    /// Maps the given 3-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 3-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,] Select<T, U>(this T[,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        U[,,] result = new U[dim0, dim1, dim2];

        Parallel.For(0, dim0 * dim1 * dim2, i => {
            int index0 = i / dim2 / dim1;
            int index1 = i / dim2 % dim1;
            int index2 = i % dim2;

            result[index0, index1, index2] = map(array[index0, index1, index2]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(collection));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim2;
            int index2 = i % dim2;

            reshaped[index1, index2] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 2-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 2-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        T[] flattened = new T[dim1 * dim2];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim2;
            int index2 = i % dim2;

            flattened[i] = array[index1, index2];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 2-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 2-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int insize = indim1 * indim2;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim2;
            int inindex2 = i % indim2;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/> -> <typeparamref name="T2"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2> ToFunctionPointer<T0, T1, T2>(void* pointer) =>
        (delegate*<T0, T1, T2>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, void> ToActionPointer<T0, T1, T2>(void* pointer) =>
        (delegate*<T0, T1, T2, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1, T2> ToFunction<T0, T1, T2>(delegate*<T0, T1, T2> pointer) =>
        new((arg0, arg1) => pointer(arg0, arg1));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1, T2> ToAction<T0, T1, T2>(delegate*<T0, T1, T2, void> pointer) =>
        new((arg0, arg1, arg2) => pointer(arg0, arg1, arg2));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/> -> <typeparamref name="T2"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T2 InvokeFunction<T0, T1, T2>(void* pointer, T0 arg0, T1 arg1) =>
        ToFunctionPointer<T0, T1, T2>(pointer)(arg0, arg1);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2>(void* pointer, T0 arg0, T1 arg1, T2 arg2) =>
        ToActionPointer<T0, T1, T2>(pointer)(arg0, arg1, arg2);

    /// <summary>
    /// Maps the given 4-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 4-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,] Select<T, U>(this T[,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        U[,,,] result = new U[dim0, dim1, dim2, dim3];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3, i => {
            int index0 = i / dim3 / dim2 / dim1;
            int index1 = i / dim3 / dim2 % dim1;
            int index2 = i / dim3 % dim2;
            int index3 = i % dim3;

            result[index0, index1, index2, index3] = map(array[index0, index1, index2, index3]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(collection));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim3 / dim2;
            int index2 = i / dim3 % dim2;
            int index3 = i % dim3;

            reshaped[index1, index2, index3] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 3-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 3-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        int dim3 = array.GetLength(2);
        T[] flattened = new T[dim1 * dim2 * dim3];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim3 / dim2;
            int index2 = i / dim3 % dim2;
            int index3 = i % dim3;

            flattened[i] = array[index1, index2, index3];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 3-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 3-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int insize = indim1 * indim2 * indim3;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim3 / indim2;
            int inindex2 = i / indim3 % indim2;
            int inindex3 = i % indim3;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 3-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 3-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int insize = indim1 * indim2 * indim3;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim3 / indim2;
            int inindex2 = i / indim3 % indim2;
            int inindex3 = i % indim3;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/> -> <typeparamref name="T3"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3> ToFunctionPointer<T0, T1, T2, T3>(void* pointer) =>
        (delegate*<T0, T1, T2, T3>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, void> ToActionPointer<T0, T1, T2, T3>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1, T2, T3> ToFunction<T0, T1, T2, T3>(delegate*<T0, T1, T2, T3> pointer) =>
        new((arg0, arg1, arg2) => pointer(arg0, arg1, arg2));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1, T2, T3> ToAction<T0, T1, T2, T3>(delegate*<T0, T1, T2, T3, void> pointer) =>
        new((arg0, arg1, arg2, arg3) => pointer(arg0, arg1, arg2, arg3));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/> -> <typeparamref name="T3"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T3 InvokeFunction<T0, T1, T2, T3>(void* pointer, T0 arg0, T1 arg1, T2 arg2) =>
        ToFunctionPointer<T0, T1, T2, T3>(pointer)(arg0, arg1, arg2);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3) =>
        ToActionPointer<T0, T1, T2, T3>(pointer)(arg0, arg1, arg2, arg3);

    /// <summary>
    /// Maps the given 5-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 5-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,] Select<T, U>(this T[,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        U[,,,,] result = new U[dim0, dim1, dim2, dim3, dim4];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4, i => {
            int index0 = i / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim4 / dim3 % dim2;
            int index3 = i / dim4 % dim3;
            int index4 = i % dim4;

            result[index0, index1, index2, index3, index4] = map(array[index0, index1, index2, index3, index4]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(collection));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim4 / dim3 / dim2;
            int index2 = i / dim4 / dim3 % dim2;
            int index3 = i / dim4 % dim3;
            int index4 = i % dim4;

            reshaped[index1, index2, index3, index4] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 4-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 4-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        int dim3 = array.GetLength(2);
        int dim4 = array.GetLength(3);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim4 / dim3 / dim2;
            int index2 = i / dim4 / dim3 % dim2;
            int index3 = i / dim4 % dim3;
            int index4 = i % dim4;

            flattened[i] = array[index1, index2, index3, index4];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 4-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 4-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int insize = indim1 * indim2 * indim3 * indim4;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim4 / indim3 / indim2;
            int inindex2 = i / indim4 / indim3 % indim2;
            int inindex3 = i / indim4 % indim3;
            int inindex4 = i % indim4;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 4-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 4-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int insize = indim1 * indim2 * indim3 * indim4;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim4 / indim3 / indim2;
            int inindex2 = i / indim4 / indim3 % indim2;
            int inindex3 = i / indim4 % indim3;
            int inindex4 = i % indim4;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 4-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 4-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int insize = indim1 * indim2 * indim3 * indim4;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim4 / indim3 / indim2;
            int inindex2 = i / indim4 / indim3 % indim2;
            int inindex3 = i / indim4 % indim3;
            int inindex4 = i % indim4;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/> -> <typeparamref name="T4"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4> ToFunctionPointer<T0, T1, T2, T3, T4>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, void> ToActionPointer<T0, T1, T2, T3, T4>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1, T2, T3, T4> ToFunction<T0, T1, T2, T3, T4>(delegate*<T0, T1, T2, T3, T4> pointer) =>
        new((arg0, arg1, arg2, arg3) => pointer(arg0, arg1, arg2, arg3));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1, T2, T3, T4> ToAction<T0, T1, T2, T3, T4>(delegate*<T0, T1, T2, T3, T4, void> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4) => pointer(arg0, arg1, arg2, arg3, arg4));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/> -> <typeparamref name="T4"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T4 InvokeFunction<T0, T1, T2, T3, T4>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3) =>
        ToFunctionPointer<T0, T1, T2, T3, T4>(pointer)(arg0, arg1, arg2, arg3);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) =>
        ToActionPointer<T0, T1, T2, T3, T4>(pointer)(arg0, arg1, arg2, arg3, arg4);

    /// <summary>
    /// Maps the given 6-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 6-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,] Select<T, U>(this T[,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        U[,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5, i => {
            int index0 = i / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim5 / dim4 % dim3;
            int index4 = i / dim5 % dim4;
            int index5 = i % dim5;

            result[index0, index1, index2, index3, index4, index5] = map(array[index0, index1, index2, index3, index4, index5]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(collection));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim5 / dim4 % dim3;
            int index4 = i / dim5 % dim4;
            int index5 = i % dim5;

            reshaped[index1, index2, index3, index4, index5] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 5-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        int dim3 = array.GetLength(2);
        int dim4 = array.GetLength(3);
        int dim5 = array.GetLength(4);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim5 / dim4 % dim3;
            int index4 = i / dim5 % dim4;
            int index5 = i % dim5;

            flattened[i] = array[index1, index2, index3, index4, index5];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 5-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim5 / indim4 % indim3;
            int inindex4 = i / indim5 % indim4;
            int inindex5 = i % indim5;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 5-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim5 / indim4 % indim3;
            int inindex4 = i / indim5 % indim4;
            int inindex5 = i % indim5;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 5-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim5 / indim4 % indim3;
            int inindex4 = i / indim5 % indim4;
            int inindex5 = i % indim5;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 5-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 5-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim5 / indim4 % indim3;
            int inindex4 = i / indim5 % indim4;
            int inindex5 = i % indim5;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/> -> <typeparamref name="T5"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5> ToFunctionPointer<T0, T1, T2, T3, T4, T5>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, void> ToActionPointer<T0, T1, T2, T3, T4, T5>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1, T2, T3, T4, T5> ToFunction<T0, T1, T2, T3, T4, T5>(delegate*<T0, T1, T2, T3, T4, T5> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4) => pointer(arg0, arg1, arg2, arg3, arg4));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1, T2, T3, T4, T5> ToAction<T0, T1, T2, T3, T4, T5>(delegate*<T0, T1, T2, T3, T4, T5, void> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5) => pointer(arg0, arg1, arg2, arg3, arg4, arg5));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/> -> <typeparamref name="T5"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T5 InvokeFunction<T0, T1, T2, T3, T4, T5>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5>(pointer)(arg0, arg1, arg2, arg3, arg4);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5);

    /// <summary>
    /// Maps the given 7-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 7-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,] Select<T, U>(this T[,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        U[,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6, i => {
            int index0 = i / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim6 / dim5 % dim4;
            int index5 = i / dim6 % dim5;
            int index6 = i % dim6;

            result[index0, index1, index2, index3, index4, index5, index6] = map(array[index0, index1, index2, index3, index4, index5, index6]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(collection));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim6 / dim5 % dim4;
            int index5 = i / dim6 % dim5;
            int index6 = i % dim6;

            reshaped[index1, index2, index3, index4, index5, index6] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 6-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        int dim3 = array.GetLength(2);
        int dim4 = array.GetLength(3);
        int dim5 = array.GetLength(4);
        int dim6 = array.GetLength(5);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim6 / dim5 % dim4;
            int index5 = i / dim6 % dim5;
            int index6 = i % dim6;

            flattened[i] = array[index1, index2, index3, index4, index5, index6];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 6-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 6-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim6 / indim5 % indim4;
            int inindex5 = i / indim6 % indim5;
            int inindex6 = i % indim6;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/> -> <typeparamref name="T6"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1, T2, T3, T4, T5, T6> ToFunction<T0, T1, T2, T3, T4, T5, T6>(delegate*<T0, T1, T2, T3, T4, T5, T6> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5) => pointer(arg0, arg1, arg2, arg3, arg4, arg5));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1, T2, T3, T4, T5, T6> ToAction<T0, T1, T2, T3, T4, T5, T6>(delegate*<T0, T1, T2, T3, T4, T5, T6, void> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5, arg6) => pointer(arg0, arg1, arg2, arg3, arg4, arg5, arg6));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/> -> <typeparamref name="T6"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T6 InvokeFunction<T0, T1, T2, T3, T4, T5, T6>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6);

    /// <summary>
    /// Maps the given 8-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 8-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,] Select<T, U>(this T[,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        U[,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7, i => {
            int index0 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim7 / dim6 % dim5;
            int index6 = i / dim7 % dim6;
            int index7 = i % dim7;

            result[index0, index1, index2, index3, index4, index5, index6, index7] = map(array[index0, index1, index2, index3, index4, index5, index6, index7]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(collection));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim7 / dim6 % dim5;
            int index6 = i / dim7 % dim6;
            int index7 = i % dim7;

            reshaped[index1, index2, index3, index4, index5, index6, index7] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 7-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        int dim3 = array.GetLength(2);
        int dim4 = array.GetLength(3);
        int dim5 = array.GetLength(4);
        int dim6 = array.GetLength(5);
        int dim7 = array.GetLength(6);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim7 / dim6 % dim5;
            int index6 = i / dim7 % dim6;
            int index7 = i % dim7;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 7-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 7-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim7 / indim6 % indim5;
            int inindex6 = i / indim7 % indim6;
            int inindex7 = i % indim7;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/> -> <typeparamref name="T7"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1, T2, T3, T4, T5, T6, T7> ToFunction<T0, T1, T2, T3, T4, T5, T6, T7>(delegate*<T0, T1, T2, T3, T4, T5, T6, T7> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5, arg6) => pointer(arg0, arg1, arg2, arg3, arg4, arg5, arg6));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1, T2, T3, T4, T5, T6, T7> ToAction<T0, T1, T2, T3, T4, T5, T6, T7>(delegate*<T0, T1, T2, T3, T4, T5, T6, T7, void> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) => pointer(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/> -> <typeparamref name="T7"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T7 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

    /// <summary>
    /// Maps the given 9-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 9-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,] Select<T, U>(this T[,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        U[,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8, i => {
            int index0 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim8 / dim7 % dim6;
            int index7 = i / dim8 % dim7;
            int index8 = i % dim8;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(collection));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim8 / dim7 % dim6;
            int index7 = i / dim8 % dim7;
            int index8 = i % dim8;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 8-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        int dim3 = array.GetLength(2);
        int dim4 = array.GetLength(3);
        int dim5 = array.GetLength(4);
        int dim6 = array.GetLength(5);
        int dim7 = array.GetLength(6);
        int dim8 = array.GetLength(7);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim8 / dim7 % dim6;
            int index7 = i / dim8 % dim7;
            int index8 = i % dim8;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 8-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 8-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <param name="dim8">The size of dimension 8.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim8 / indim7 % indim6;
            int inindex7 = i / indim8 % indim7;
            int inindex8 = i % indim8;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/> -> <typeparamref name="T8"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1, T2, T3, T4, T5, T6, T7, T8> ToFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8>(delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) => pointer(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1, T2, T3, T4, T5, T6, T7, T8> ToAction<T0, T1, T2, T3, T4, T5, T6, T7, T8>(delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, void> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) => pointer(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/> -> <typeparamref name="T8"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T8 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

    /// <summary>
    /// Maps the given 10-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 10-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        U[,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9, i => {
            int index0 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim9 / dim8 % dim7;
            int index8 = i / dim9 % dim8;
            int index9 = i % dim9;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(collection));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim9 / dim8 % dim7;
            int index8 = i / dim9 % dim8;
            int index9 = i % dim9;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 9-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        int dim3 = array.GetLength(2);
        int dim4 = array.GetLength(3);
        int dim5 = array.GetLength(4);
        int dim6 = array.GetLength(5);
        int dim7 = array.GetLength(6);
        int dim8 = array.GetLength(7);
        int dim9 = array.GetLength(8);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim9 / dim8 % dim7;
            int index8 = i / dim9 % dim8;
            int index9 = i % dim9;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <param name="dim8">The size of dimension 8.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 9-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 9-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <param name="dim8">The size of dimension 8.</param>
    /// <param name="dim9">The size of dimension 9.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim9 / indim8 % indim7;
            int inindex8 = i / indim9 % indim8;
            int inindex9 = i % indim9;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9];
        });

        return reshaped;
    }

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/> -> <typeparamref name="T9"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, void> ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(void* pointer) =>
        (delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, void>)pointer;

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Func{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ToFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) => pointer(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));

    /// <summary>
    /// Casts the given <see langword="delegate"/>-pointer to an instance of <see cref="Action{}"/> by wrapping it using an internal lambda.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ToAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(delegate*<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, void> pointer) =>
        new((arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) => pointer(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/> -> <typeparamref name="T9"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <param name="arg1">The argument no. 2.</param>
    /// <param name="arg2">The argument no. 3.</param>
    /// <param name="arg3">The argument no. 4.</param>
    /// <param name="arg4">The argument no. 5.</param>
    /// <param name="arg5">The argument no. 6.</param>
    /// <param name="arg6">The argument no. 7.</param>
    /// <param name="arg7">The argument no. 8.</param>
    /// <param name="arg8">The argument no. 9.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T9 InvokeFunction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) =>
        ToFunctionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <typeparamref name="T0"/>, <typeparamref name="T1"/>, <typeparamref name="T2"/>, <typeparamref name="T3"/>, <typeparamref name="T4"/>, <typeparamref name="T5"/>, <typeparamref name="T6"/>, <typeparamref name="T7"/>, <typeparamref name="T8"/>, <typeparamref name="T9"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <typeparam name="T0">The generic type parameter <typeparamref name="T0"/>.</typeparam>
    /// <param name="arg0">The argument no. 1.</param>
    /// <typeparam name="T1">The generic type parameter <typeparamref name="T1"/>.</typeparam>
    /// <param name="arg1">The argument no. 2.</param>
    /// <typeparam name="T2">The generic type parameter <typeparamref name="T2"/>.</typeparam>
    /// <param name="arg2">The argument no. 3.</param>
    /// <typeparam name="T3">The generic type parameter <typeparamref name="T3"/>.</typeparam>
    /// <param name="arg3">The argument no. 4.</param>
    /// <typeparam name="T4">The generic type parameter <typeparamref name="T4"/>.</typeparam>
    /// <param name="arg4">The argument no. 5.</param>
    /// <typeparam name="T5">The generic type parameter <typeparamref name="T5"/>.</typeparam>
    /// <param name="arg5">The argument no. 6.</param>
    /// <typeparam name="T6">The generic type parameter <typeparamref name="T6"/>.</typeparam>
    /// <param name="arg6">The argument no. 7.</param>
    /// <typeparam name="T7">The generic type parameter <typeparamref name="T7"/>.</typeparam>
    /// <param name="arg7">The argument no. 8.</param>
    /// <typeparam name="T8">The generic type parameter <typeparamref name="T8"/>.</typeparam>
    /// <param name="arg8">The argument no. 9.</param>
    /// <typeparam name="T9">The generic type parameter <typeparamref name="T9"/>.</typeparam>
    /// <param name="arg9">The argument no. 10.</param>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(void* pointer, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) =>
        ToActionPointer<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(pointer)(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

    /// <summary>
    /// Maps the given 11-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input 11-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting 11-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[,,,,,,,,,,] Select<T, U>(this T[,,,,,,,,,,] array, Func<T, U> map)
    {
        int dim0 = array.GetLength(0);
        int dim1 = array.GetLength(1);
        int dim2 = array.GetLength(2);
        int dim3 = array.GetLength(3);
        int dim4 = array.GetLength(4);
        int dim5 = array.GetLength(5);
        int dim6 = array.GetLength(6);
        int dim7 = array.GetLength(7);
        int dim8 = array.GetLength(8);
        int dim9 = array.GetLength(9);
        int dim10 = array.GetLength(10);
        U[,,,,,,,,,,] result = new U[dim0, dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, dim0 * dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10, i => {
            int index0 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 / dim1;
            int index1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2 % dim1;
            int index2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim10 / dim9 % dim8;
            int index9 = i / dim10 % dim9;
            int index10 = i % dim10;

            result[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10] = map(array[index0, index1, index2, index3, index4, index5, index6, index7, index8, index9, index10]);
        });

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this IEnumerable<T> collection, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(collection));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int index1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim10 / dim9 % dim8;
            int index9 = i / dim10 % dim9;
            int index10 = i % dim10;

            reshaped[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given 10-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[,,,,,,,,,] array)
    {
        int dim1 = array.GetLength(0);
        int dim2 = array.GetLength(1);
        int dim3 = array.GetLength(2);
        int dim4 = array.GetLength(3);
        int dim5 = array.GetLength(4);
        int dim6 = array.GetLength(5);
        int dim7 = array.GetLength(6);
        int dim8 = array.GetLength(7);
        int dim9 = array.GetLength(8);
        int dim10 = array.GetLength(9);
        T[] flattened = new T[dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10];

        Parallel.For(0, flattened.Length, i => {
            int index1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int index2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int index3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int index4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int index5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int index6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int index7 = i / dim10 / dim9 / dim8 % dim7;
            int index8 = i / dim10 / dim9 % dim8;
            int index9 = i / dim10 % dim9;
            int index10 = i % dim10;

            flattened[i] = array[index1, index2, index3, index4, index5, index6, index7, index8, index9, index10];
        });

        return flattened;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 2-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <returns>The reshaped 2-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2}.", nameof(array));

        T[,] reshaped = new T[dim1, dim2];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim2;
            int outindex2 = i % dim2;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 3-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <returns>The reshaped 3-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3}.", nameof(array));

        T[,,] reshaped = new T[dim1, dim2, dim3];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim3 / dim2;
            int outindex2 = i / dim3 % dim2;
            int outindex3 = i % dim3;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 4-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <returns>The reshaped 4-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4}.", nameof(array));

        T[,,,] reshaped = new T[dim1, dim2, dim3, dim4];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim4 / dim3 / dim2;
            int outindex2 = i / dim4 / dim3 % dim2;
            int outindex3 = i / dim4 % dim3;
            int outindex4 = i % dim4;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 5-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <returns>The reshaped 5-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5}.", nameof(array));

        T[,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim5 / dim4 % dim3;
            int outindex4 = i / dim5 % dim4;
            int outindex5 = i % dim5;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 6-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <returns>The reshaped 6-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6}.", nameof(array));

        T[,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim6 / dim5 % dim4;
            int outindex5 = i / dim6 % dim5;
            int outindex6 = i % dim6;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 7-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <returns>The reshaped 7-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7}.", nameof(array));

        T[,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim7 / dim6 % dim5;
            int outindex6 = i / dim7 % dim6;
            int outindex7 = i % dim7;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 8-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <param name="dim8">The size of dimension 8.</param>
    /// <returns>The reshaped 8-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8}.", nameof(array));

        T[,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim8 / dim7 % dim6;
            int outindex7 = i / dim8 % dim7;
            int outindex8 = i % dim8;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 9-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <param name="dim8">The size of dimension 8.</param>
    /// <param name="dim9">The size of dimension 9.</param>
    /// <returns>The reshaped 9-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9}.", nameof(array));

        T[,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim9 / dim8 % dim7;
            int outindex8 = i / dim9 % dim8;
            int outindex9 = i % dim9;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }

    /// <summary>
    /// Reshapes the given 10-dimensional array into a 10-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The 10-dimensional input array.</param>
    /// <param name="dim1">The size of dimension 1.</param>
    /// <param name="dim2">The size of dimension 2.</param>
    /// <param name="dim3">The size of dimension 3.</param>
    /// <param name="dim4">The size of dimension 4.</param>
    /// <param name="dim5">The size of dimension 5.</param>
    /// <param name="dim6">The size of dimension 6.</param>
    /// <param name="dim7">The size of dimension 7.</param>
    /// <param name="dim8">The size of dimension 8.</param>
    /// <param name="dim9">The size of dimension 9.</param>
    /// <param name="dim10">The size of dimension 10.</param>
    /// <returns>The reshaped 10-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[,,,,,,,,,] Reshape<T>(this T[,,,,,,,,,] array, int dim1, int dim2, int dim3, int dim4, int dim5, int dim6, int dim7, int dim8, int dim9, int dim10)
    {
        int indim1 = array.GetLength(0);
        int indim2 = array.GetLength(1);
        int indim3 = array.GetLength(2);
        int indim4 = array.GetLength(3);
        int indim5 = array.GetLength(4);
        int indim6 = array.GetLength(5);
        int indim7 = array.GetLength(6);
        int indim8 = array.GetLength(7);
        int indim9 = array.GetLength(8);
        int indim10 = array.GetLength(9);
        int insize = indim1 * indim2 * indim3 * indim4 * indim5 * indim6 * indim7 * indim8 * indim9 * indim10;
        int outsize = dim1 * dim2 * dim3 * dim4 * dim5 * dim6 * dim7 * dim8 * dim9 * dim10;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {indim1} x {indim2} x {indim3} x {indim4} x {indim5} x {indim6} x {indim7} x {indim8} x {indim9} x {indim10}), which is less than the required length of {outsize} = {dim1} x {dim2} x {dim3} x {dim4} x {dim5} x {dim6} x {dim7} x {dim8} x {dim9} x {dim10}.", nameof(array));

        T[,,,,,,,,,] reshaped = new T[dim1, dim2, dim3, dim4, dim5, dim6, dim7, dim8, dim9, dim10];

        Parallel.For(0, outsize, i => {
            int outindex1 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 / dim2;
            int outindex2 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 / dim3 % dim2;
            int outindex3 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 / dim4 % dim3;
            int outindex4 = i / dim10 / dim9 / dim8 / dim7 / dim6 / dim5 % dim4;
            int outindex5 = i / dim10 / dim9 / dim8 / dim7 / dim6 % dim5;
            int outindex6 = i / dim10 / dim9 / dim8 / dim7 % dim6;
            int outindex7 = i / dim10 / dim9 / dim8 % dim7;
            int outindex8 = i / dim10 / dim9 % dim8;
            int outindex9 = i / dim10 % dim9;
            int outindex10 = i % dim10;
            int inindex1 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 / indim2;
            int inindex2 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 / indim3 % indim2;
            int inindex3 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 / indim4 % indim3;
            int inindex4 = i / indim10 / indim9 / indim8 / indim7 / indim6 / indim5 % indim4;
            int inindex5 = i / indim10 / indim9 / indim8 / indim7 / indim6 % indim5;
            int inindex6 = i / indim10 / indim9 / indim8 / indim7 % indim6;
            int inindex7 = i / indim10 / indim9 / indim8 % indim7;
            int inindex8 = i / indim10 / indim9 % indim8;
            int inindex9 = i / indim10 % indim9;
            int inindex10 = i % indim10;

            reshaped[outindex1, outindex2, outindex3, outindex4, outindex5, outindex6, outindex7, outindex8, outindex9, outindex10] = array[inindex1, inindex2, inindex3, inindex4, inindex5, inindex6, inindex7, inindex8, inindex9, inindex10];
        });

        return reshaped;
    }
}

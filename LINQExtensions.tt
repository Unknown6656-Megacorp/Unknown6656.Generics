<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
////////////////////////////////////////////////////// AUTOGENERATED //////////////////////////////////////////////////////
// WARNING: All code changes to this file will be lost upon regeneration.                                                //
// Autogenerated on <#=$"{DateTime.Now:yyyy-MM-dd HH:mm:ss:ffffff}"#>                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;
using System;

namespace Unknown6656.Generics;


public static unsafe partial class LINQ
{
<#
    int maxsize = 10;

    try
    {
        string path = Host.ResolvePath("maxdim.txt");

        maxsize = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

    for (int dim = 2; dim <= maxsize; ++dim)
    {
        string[] types = r(0, dim).Select(i => $"T{i}").ToArray();
        string res_type = string.Join(", ", types);

        if (dim > 2)
            for (int i = 1; i < dim; ++i)
            {
                string left = string.Join(", ", types.Take(i));
                string right = string.Join(", ", types.Skip(i));
                string left_acc = "tuple.left";
                string right_acc = "tuple.right";

                if (i > 1)
                {
                    left = $"({left})";
                    left_acc = string.Join(", ", r(1, i).Select(j => $"tuple.left.Item{j}").ToArray());
                }

                if (i < dim - 1)
                {
                    right = $"({right})";
                    right_acc = string.Join(", ", r(1, dim - i).Select(j => $"tuple.right.Item{j}").ToArray());
                }
#>

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
<#
                for (int j = 0; j < dim; ++j)
                {
#>
    /// <typeparam name="T<#=j#>">The generic type parameter <typeparamref name="T<#=j#>"/>.</typeparam>
<#
                }
#>
    /// <param name="tuple">The tuple which is comprised of two tuple halves.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (<#=res_type#>) Join<<#=res_type#>>(this (<#=left#> left, <#=right#> right) tuple) =>
        (<#=left_acc#>, <#=right_acc#>);

    /// <summary>
    /// Joins the two given tuple halves together and returns the joint tuple.
    /// </summary>
<#
                for (int j = 0; j < dim; ++j)
                {
#>
    /// <typeparam name="T<#=j#>">The generic type parameter <typeparamref name="T<#=j#>"/>.</typeparam>
<#
                }
#>
    /// <param name="left">The left-hand half.</param>
    /// <param name="right">The right-hand half.</param>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (<#=res_type#>) Join<<#=res_type#>>(this <#=left#> left, <#=right#> right) =>
        (<#=left_acc.Replace("tuple.", "")#>, <#=right_acc.Replace("tuple.", "")#>);
<#
             }
#>

    /// <summary>
    /// Joins the given the given elements to a common tuple.
    /// </summary>
<#
        for (int j = 0; j < dim; ++j)
        {
#>
    /// <param name="t<#=j#>">The tuple element at position <#=j + 1#>.</param>
    /// <typeparam name="T<#=j#>">The generic type parameter <typeparamref name="T<#=j#>"/> for the argument <paramref name="t<#=j#>"/>.</typeparam>
<#
        }
#>
    /// <returns>The merged tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (<#=res_type#>) Join<<#=res_type#>>(this <#=string.Join(", ", types.Select((t, i) => $"{t} t{i}"))#>) =>
        (<#=res_type.ToLower()#>);

    /// <summary>
    /// Creates a new array with exactly <#=dim#> elements from the given <#=dim#>-tuple.
    /// </summary>
    /// <typeparam name="T">The generic type parameter.</typeparam>
    /// <param name="tuple">A <#=dim#>-tuple.</param>
    /// <returns>The array (Length = <#=dim#>) corresponding to the given tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] ToArray<T>(this (<#=string.Join(", ", r(0, dim).Select(i => $"T t{i}"))#>) tuple) =>
        new[] { <#=string.Join(", ", r(0, dim).Select(i => "tuple.t" + i))#> };

    /// <summary>
    /// Applies the given function <paramref name="func"/> to all elements of the given tuple <paramref name="x"/>.
    /// </summary>
    /// <typeparam name="T">The generic input tuple element type parameter.</typeparam>
    /// <typeparam name="U">The generic output tuple element type parameter.</typeparam>
    /// <param name="x">The input tuple.</param>
    /// <param name="func">The function to be applied element-wise to <paramref name="x"/>.</param>
    /// <returns>The resulting tuple.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static (<#=string.Join(", ", r(0, dim).Select(i => "U e" + i))#>) Apply<T, U>(this (<#=string.Join(", ", r(0, dim).Select(i => "T e" + i))#>) x, Func<T, U> func) =>
        (<#=string.Join(", ", r(0, dim).Select(i => $"func(x.e{i})"))#>);
<#
    }
#>

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// </summary>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<void> ToActionPointer(void* pointer) => (delegate*<void>)pointer;

    public static Action ToAction(delegate*<void> pointer) => () => pointer();

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <see langword="void"/> -> <see langword="void"/>
    /// </code>
    /// </summary>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction(void* pointer) => ToActionPointer(pointer)();
<#
    for (int dim = 1; dim <= maxsize; ++dim)
    {
        string types = string.Join(", ", r(0, dim).Select(i =>  "T" + i));
        string fpars = string.Concat(r(0, dim - 1).Select(i =>  $", T{i} arg{i}"));
        string fargs = string.Join(", ", r(0, dim - 1).Select(i =>  "arg" + i));
        string apars = string.Concat(r(0, dim).Select(i =>  $", T{i} arg{i}"));
        string aargs = string.Join(", ", r(0, dim).Select(i =>  "arg" + i));
#>

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <#=string.Join(", ", r(0, dim - 1).Select(i =>  $"<typeparamref name=\"T{i}\"/>"))#> -> <typeparamref name="T<#=dim - 1#>"/>
    /// </code>
    /// </summary>
<#
        for (int i = 0; i < dim; ++i)
        {
#>
    /// <typeparam name="T<#=i#>">The generic type parameter <typeparamref name="T<#=i#>"/>.</typeparam>
<#
        }
#>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<<#=types#>> ToFunctionPointer<<#=types#>>(void* pointer) =>
        (delegate*<<#=types#>>)pointer;

    /// <summary>
    /// Casts the given <see langword="void"/>-pointer to a <see langword="delegate"/>-pointer using the given type arguments.
    /// The resulting <see langword="delegate"/>-pointer has the following method signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <#=string.Join(", ", r(0, dim).Select(i =>  $"<typeparamref name=\"T{i}\"/>"))#> -> <see langword="void"/>
    /// </code>
    /// </summary>
<#
        for (int i = 0; i < dim; ++i)
        {
#>
    /// <typeparam name="T<#=i#>">The generic type parameter <typeparamref name="T<#=i#>"/>.</typeparam>
<#
        }
#>
    /// <param name="pointer">The <see langword="void"/>-pointer.</param>
    /// <returns>The resulting <see langword="delegate"/>-pointer which points to the same address.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static delegate*<<#=types#>, void> ToActionPointer<<#=types#>>(void* pointer) =>
        (delegate*<<#=types#>, void>)pointer;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Func<<#=types#>> ToFunction<<#=types#>>(delegate*<<#=types#>> pointer) =>
        new((<#=fargs#>) => pointer(<#=fargs#>));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Action<<#=types#>> ToAction<<#=types#>>(delegate*<<#=types#>, void> pointer) =>
        new((<#=aargs#>) => pointer(<#=aargs#>));

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <#=string.Join(", ", r(0, dim - 1).Select(i =>  $"<typeparamref name=\"T{i}\"/>"))#> -> <typeparamref name="T<#=dim - 1#>"/>
    /// </code>
    /// </summary>
<#
        for (int i = 0; i < dim; ++i)
        {
#>
    /// <typeparam name="T<#=i#>">The generic type parameter <typeparamref name="T<#=i#>"/>.</typeparam>
<#
        }
        
        for (int i = 0; i < dim - 1; ++i)
        {
#>
    /// <param name="arg<#=i#>">The argument no. <#=i + 1#>.</param>
<#
        }
#>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    /// <returns>The invoked function's return value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T<#=dim - 1#> InvokeFunction<<#=types#>>(void* pointer<#=fpars#>) =>
        ToFunctionPointer<<#=types#>>(pointer)(<#=fargs#>);

    /// <summary>
    /// Invokes the given <see langword="void"/>-pointer with the given arguments as a method with the following signature:
    /// <para/>
    /// <para/>
    /// <code>
    /// <#=string.Join(", ", r(0, dim).Select(i =>  $"<typeparamref name=\"T{i}\"/>"))#> -> <see langword="void"/>
    /// </code>
    /// </summary>
<#
        for (int i = 0; i < dim; ++i)
        {
#>
    /// <typeparam name="T<#=i#>">The generic type parameter <typeparamref name="T<#=i#>"/>.</typeparam>
    /// <param name="arg<#=i#>">The argument no. <#=i + 1#>.</param>
<#
        }
#>
    /// <param name="pointer">The <see langword="void"/>-pointer which points to a valid function.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InvokeAction<<#=types#>>(void* pointer<#=apars#>) =>
        ToActionPointer<<#=types#>>(pointer)(<#=aargs#>);

    /// <summary>
    /// Maps the given <#=dim + 1#>-dimensional array from the generic element type <typeparamref name="T"/> to the generic element type <typeparamref name="U"/>.
    /// </summary>
    /// <typeparam name="T">The generic type parameter <typeparamref name="T"/>.</typeparam>
    /// <typeparam name="U">The generic type parameter <typeparamref name="U"/>.</typeparam>
    /// <param name="array">The input <#=dim + 1#>-dimensional array.</param>
    /// <param name="map">The mapping function.</param>
    /// <returns>The resulting <#=dim + 1#>-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static U[<#=new string(',', dim)#>] Select<T, U>(this T[<#=new string(',', dim)#>] array, Func<T, U> map)
    {
<#
        for (int i = 0; i <= dim; ++i)
            WriteLine($"        int dim{i} = array.GetLength({i});");
#>
        U[<#=new string(',', dim)#>] result = new U[<#=string.Join(", ", r(0, dim + 1).Select(i => "dim" + i))#>];

        Parallel.For(0, <#=string.Join(" * ", r(0, dim + 1).Select(i => "dim" + i))#>, i => {
<#
            for (int i = 0; i <= dim; ++i)
            {
                string idx = "i";

                for (int j = dim; j > i; --j)
                    idx += $" / dim{j}";

                if (i > 0)
                    idx += $" % dim{i}";

                WriteLine($"            int index{i} = {idx};");
            }

            string map_idx = string.Join(", ", r(0, dim + 1).Select(i => "index" + i));
#>

            result[<#=map_idx#>] = map(array[<#=map_idx#>]);
        });

        return result;
    }

<#
        if (dim >= 2)
        {
#>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[<#=new string(',', dim - 1)#>] Reshape<T>(this IEnumerable<T> collection, <#=string.Join(", ", r(1, dim).Select(i => "int dim" + i))#>)
    {
        T[] items = collection as T[] ?? collection.ToArray();
        int outsize = <#=string.Join(" * ", r(1, dim).Select(i => "dim" + i))#>;

        if (outsize < items.Length)
            throw new ArgumentException($"The given input collection has a length of {items.Length}, which is less than the required length of {outsize} = {<#=string.Join("} x {", r(1, dim).Select(i => "dim" + i))#>}.", nameof(collection));

        T[<#=new string(',', dim - 1)#>] reshaped = new T[<#=string.Join(", ", r(1, dim).Select(i => "dim" + i))#>];

        Parallel.For(0, outsize, i => {
<#
            for (int i = 1; i <= dim; ++i)
            {
                string idx = "i";

                for (int j = dim; j > i; --j)
                    idx += $" / dim{j}";

                if (i > 1)
                    idx += $" % dim{i}";

                WriteLine($"            int index{i} = {idx};");
            }
#>

            reshaped[<#=string.Join(", ", r(1, dim).Select(i => "index" + i))#>] = items[i];
        });

        return reshaped;
    }
    
    /// <summary>
    /// Flattens the given <#=dim#>-dimensional array into a one-dimensional array using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The <#=dim#>-dimensional input array.</param>
    /// <returns>The flattened one-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[] Flatten<T>(this T[<#=new string(',', dim - 1)#>] array)
    {
<#
        for (int i = 1; i <= dim; ++i)
            WriteLine($"        int dim{i} = array.GetLength({i});");
#>
        T[] flattened = new T[<#=string.Join(" * ", r(1, dim).Select(i => "dim" + i))#>];

        Parallel.For(0, flattened.Length, i => {
<#
            for (int i = 1; i <= dim; ++i)
            {
                string idx = "i";

                for (int j = dim; j > i; --j)
                    idx += $" / dim{j}";

                if (i > 1)
                    idx += $" % dim{i}";
#>
            int index<#=i#> = <#=idx#>;
<#
            }
#>

            flattened[i] = array[<#=string.Join(", ", r(1, dim).Select(i => "index" + i))#>];
        });

        return flattened;
    }
<#
            for (int outdim = 2; outdim <= dim; ++outdim)
            {
#>

    /// <summary>
    /// Reshapes the given <#=dim#>-dimensional array into a <#=outdim#>-dimensional one using the given sizes for each dimension.
    /// </summary>
    /// <typeparam name="T">The generic element type parameter <typeparamref name="T"/>.</typeparam>
    /// <param name="array">The <#=dim#>-dimensional input array.</param>
    /// <returns>The reshaped <#=outdim#>-dimensional array.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T[<#=new string(',', outdim - 1)#>] Reshape<T>(this T[<#=new string(',', dim - 1)#>] array, <#=string.Join(", ", r(1, outdim).Select(i => "int dim" + i))#>)
    {
<#
        for (int i = 1; i <= dim; ++i)
            WriteLine($"        int indim{i} = array.GetLength({i});");
#>
        int insize = <#=string.Join(" * ", r(1, dim).Select(i => "indim" + i))#>;
        int outsize = <#=string.Join(" * ", r(1, outdim).Select(i => "dim" + i))#>;

        if (outsize > insize)
            throw new ArgumentException($"The given input collection has a length of {insize} (= {<#=string.Join("} x {", r(1, dim).Select(i => "indim" + i))#>}), which is less than the required length of {outsize} = {<#=string.Join("} x {", r(1, outdim).Select(i => "dim" + i))#>}.", nameof(array));

        T[<#=new string(',', outdim - 1)#>] reshaped = new T[<#=string.Join(", ", r(1, outdim).Select(i => "dim" + i))#>];

        Parallel.For(0, outsize, i => {
<#
            for (int i = 1; i <= outdim; ++i)
            {
                string idx = "i";

                for (int j = outdim; j > i; --j)
                    idx += $" / dim{j}";

                if (i > 1)
                    idx += $" % dim{i}";

                WriteLine($"            int outindex{i} = {idx};");
            }

            for (int i = 1; i <= dim; ++i)
            {
                string idx = "i";

                for (int j = dim; j > i; --j)
                    idx += $" / indim{j}";

                if (i > 1)
                    idx += $" % indim{i}";

                WriteLine($"            int inindex{i} = {idx};");
            }
#>

            reshaped[<#=string.Join(", ", r(1, outdim).Select(i => "outindex" + i))#>] = array[<#=string.Join(", ", r(1, dim).Select(i => "inindex" + i))#>];
        });

        return reshaped;
    }
<#
            }
        }
    }
#>
}
